<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LightString</title>
  
  <subtitle>LightString</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-03-21T07:29:05.450Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>LightString</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Red Black Tree</title>
    <link href="http://example.com/2023/02/22/Red-Black-Tree/"/>
    <id>http://example.com/2023/02/22/Red-Black-Tree/</id>
    <published>2023-02-23T03:28:39.000Z</published>
    <updated>2023-03-21T07:29:05.450Z</updated>
    
    <content type="html"><![CDATA[<h2 id="What-is-Red-Black-Tree-RBT"><a href="#What-is-Red-Black-Tree-RBT" class="headerlink" title="What is Red Black Tree (RBT)?"></a>What is Red Black Tree (RBT)?</h2><p>Today let’s talk about Red Black Tree (RBT). Red Black is a kind of balanced binary search tree. Unlike regular binary search trees (BST), the speed of an RBT remains relatively consistent no matter the height of the tree, due to its self-balancing property. This attribute is achieved through a set of limitations placed on the depth and color of each node in the tree.</p><h2 id="Properties-of-RBT"><a href="#Properties-of-RBT" class="headerlink" title="Properties of RBT"></a>Properties of RBT</h2><ul><li>All properties of normal binary search trees</li><li>All nodes on trees have two colors: red and black</li><li>A red node cannot has red child or parent nodes</li><li>The root node must be black</li><li>The number of black nodes on each path from root to leaf node must be same<br>By assigning each node with a color and by limiting the number of consecutive colored nodes, RBT ensures that the longest branches will never exceed twice the size of the shortest branches, thus providing a more stable and effective tree. For reference, here’s a visual representation of an RBT:<br><img src="https://drive.google.com/uc?export=view&id=1uj8c9Md7JGe6XXoAX6HQEvo6oaGgzPHc" alt="photo_2023-02-22_21-58-43.jpg"><br>Here’s a comparison between BST and RBT when we insert “1, 2, 3, 4, 5” in order, demonstrating why RBT is far more efficient than BST when sorted elements are inserted:<br><img src="https://drive.google.com/uc?export=view&id=1ZgmVqbTb-yAB9iDVdC8rLuXuojKOPELT" alt="photo_2023-02-22_22-32-17.jpg"><br>Obviously, BST will become extremely low effective when receiving a sorted sequence. And RBT can become more balanced under this situation.</li></ul><h2 id="Search-of-RBT"><a href="#Search-of-RBT" class="headerlink" title="Search of RBT"></a>Search of RBT</h2><p>Searching an RBT is just like searching any other binary search tree – if the value of the current node is larger than the target value, the search should continue on its left child; otherwise, it should continue on its right child. Here’s an example implementation using C++:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">search</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    Node *cur = root;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// If the current node is the goal, return it </span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val == val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">move</span>(cur-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Decide whether to continue searching left or right </span></span><br><span class="line">        cur = cur-&gt;val &lt; val ? cur-&gt;left : cur-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Returns a empty vector if not found</span></span><br><span class="line">    vector&lt;string&gt; tmp;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">move</span>(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Rotate-Option-of-RBT"><a href="#Rotate-Option-of-RBT" class="headerlink" title="Rotate Option of RBT"></a>Rotate Option of RBT</h2><p>Rotate option is the key function that helps the tree balance itself without breaking its properties. There are two kinds of rotation: left rotation and right rotation. Left rotation let the left branch’s height + 1, right branch’s height - 1, right rotation reverse.</p><h3 id="Left-Rotate"><a href="#Left-Rotate" class="headerlink" title="Left Rotate"></a>Left Rotate</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node *<span class="title">leftRotate</span><span class="params">(Node *cur)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Store cur&#x27;s right&#x27;s left node in tmp</span></span><br><span class="line">    Node *tmp = cur-&gt;right-&gt;left;</span><br><span class="line">    <span class="comment">//Set cur-&gt;right-&gt;left to cur</span></span><br><span class="line">    cur-&gt;right-&gt;left = cur;</span><br><span class="line">    <span class="comment">//Set cur-&gt;parent as cur-&gt;right</span></span><br><span class="line">    cur-&gt;right-&gt;parent = cur-&gt;parent;</span><br><span class="line">    <span class="comment">//Set cur-&gt;parent to cur-&gt;right</span></span><br><span class="line">    cur-&gt;parent = cur-&gt;right;</span><br><span class="line">    <span class="comment">//Set cur-&gt;right to the previously stored tmp</span></span><br><span class="line">    <span class="comment">//node</span></span><br><span class="line">    cur-&gt;right = tmp;</span><br><span class="line">    <span class="comment">//Set cur-&gt;parent-&gt;left to cur</span></span><br><span class="line">    cur-&gt;parent-&gt;left = cur;</span><br><span class="line">    <span class="comment">//Set tmp&#x27;s parent to cur</span></span><br><span class="line">    tmp-&gt;parent = cur;</span><br><span class="line">    <span class="comment">//Determine root node when cur is being rotated.</span></span><br><span class="line">    <span class="keyword">if</span> (root == cur) &#123;</span><br><span class="line">        root = cur-&gt;parent;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//Check if Parent of the current node has cur as its left or right child</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;parent-&gt;parent-&gt;left == cur) &#123;</span><br><span class="line">            cur-&gt;parent-&gt;parent-&gt;left = cur-&gt;parent;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur-&gt;parent-&gt;parent-&gt;right = cur-&gt;parent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Return the new parent node</span></span><br><span class="line">    <span class="keyword">return</span> cur-&gt;parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Right-rotate"><a href="#Right-rotate" class="headerlink" title="Right rotate"></a>Right rotate</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node *<span class="title">rightRotate</span><span class="params">(Node *cur)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Store the subsidiary node before changing its pointer</span></span><br><span class="line">    Node *tmp = cur-&gt;left-&gt;right;</span><br><span class="line">    <span class="comment">// Make the connection between the right child of left child and the current node</span></span><br><span class="line">    cur-&gt;left-&gt;right = cur;</span><br><span class="line">    <span class="comment">// Update the parent pointer of the right child of left child</span></span><br><span class="line">    cur-&gt;left-&gt;parent = cur-&gt;parent;</span><br><span class="line">    <span class="comment">// Move the parent pointer of the current node to its left child</span></span><br><span class="line">    cur-&gt;parent = cur-&gt;left;</span><br><span class="line">    <span class="comment">// Replace the right child of the current node with the auxiliary node</span></span><br><span class="line">    cur-&gt;left = tmp;</span><br><span class="line">    <span class="comment">// Connect the auxiliary node with the current node</span></span><br><span class="line">    cur-&gt;parent-&gt;right = cur;</span><br><span class="line">    <span class="comment">// Move parent pointer from auxiliary node to cur</span></span><br><span class="line">    tmp-&gt;parent = cur;</span><br><span class="line">    <span class="comment">// Check if the current node is root or not</span></span><br><span class="line">    <span class="keyword">if</span> (root == cur) &#123;</span><br><span class="line">        <span class="comment">// If it&#x27;s, update the root pointer to its parent</span></span><br><span class="line">        root = cur-&gt;parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Check if the grand parent of the current node has a left or right child</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;parent-&gt;parent-&gt;left == cur) &#123;</span><br><span class="line">        <span class="comment">// If it has a left child, that must be the parent of the current node</span></span><br><span class="line">        cur-&gt;parent-&gt;parent-&gt;left = cur-&gt;parent;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If it has a right child, that must be the parent of the current node</span></span><br><span class="line">        cur-&gt;parent-&gt;parent-&gt;right = cur-&gt;parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur-&gt;parent;<span class="comment">// Return new node after zig operation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Insert-option-of-RBT"><a href="#Insert-option-of-RBT" class="headerlink" title="Insert option of RBT"></a>Insert option of RBT</h2><p>Because of the properties of RBT, its insert option will be more complicated than normal BST. Specifically, we can break the insert option into two steps: insert and balance. Many platforms combine the two parts with together, but from my perspective, it is not convenient for understanding.</p><h3 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h3><p>The insert option is similar to BST’s insert option. Find the approrate position and make a new node on the tree with the target value and key. When it comes to RBT, we only need to care about the new node must be RED at first.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> val, <span class="type">const</span> string &amp;data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> Node&#123;val&#125;;</span><br><span class="line">        root-&gt;is_red = <span class="number">0</span>;</span><br><span class="line">        root-&gt;data.<span class="built_in">emplace_back</span>(data);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node *cur = root;</span><br><span class="line">    Node *pre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        pre = cur;</span><br><span class="line">        <span class="keyword">if</span> (val == cur-&gt;val) &#123;</span><br><span class="line">            cur-&gt;data.<span class="built_in">emplace_back</span>(data);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (val &lt; cur-&gt;val) &#123;</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (val &gt; cur-&gt;val) &#123;</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cur = <span class="keyword">new</span> Node&#123;val&#125;;</span><br><span class="line">    cur-&gt;data.<span class="built_in">emplace_back</span>(data);</span><br><span class="line">    cur-&gt;is_red = <span class="number">1</span>;</span><br><span class="line">    cur-&gt;parent = pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Balance"><a href="#Balance" class="headerlink" title="Balance"></a>Balance</h3><p>The balance option is the key of RBT, which implement by left rotation and right rotation. Here are the strategy of balance:</p><ol><li>When the current node is the root, just turn it black.</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;What-is-Red-Black-Tree-RBT&quot;&gt;&lt;a href=&quot;#What-is-Red-Black-Tree-RBT&quot; class=&quot;headerlink&quot; title=&quot;What is Red Black Tree (RBT)?&quot;&gt;&lt;/a&gt;What </summary>
      
    
    
    
    
    <category term="data structure" scheme="http://example.com/tags/data-structure/"/>
    
  </entry>
  
  <entry>
    <title>Self Description</title>
    <link href="http://example.com/2023/02/13/SelfDescription/"/>
    <id>http://example.com/2023/02/13/SelfDescription/</id>
    <published>2023-02-13T08:26:01.000Z</published>
    <updated>2023-03-16T01:19:13.383Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Nice-to-meet-you"><a href="#Nice-to-meet-you" class="headerlink" title="Nice to meet you"></a>Nice to meet you</h2><ul><li>Im LightString. A CS major student in UW-madison. Welcome to my blog!</li><li>My birthday is June 1st. Happy children’s day!</li><li>ACG lover, Dark Soul player, Galgame lover, and so on.</li></ul><h2 id="Field-I-interested-in"><a href="#Field-I-interested-in" class="headerlink" title="Field I interested in"></a>Field I interested in</h2><ul><li>Machine Learning &amp; Deep Learning</li><li>Algorithms &amp; Data Structures</li><li>Quantitive Trading</li><li>…………</li></ul><h2 id="Contact"><a href="#Contact" class="headerlink" title="Contact"></a>Contact</h2><ul><li>Email Address: <a href="mailto:&#x6c;&#x73;&#46;&#x68;&#121;&#106;&#x69;&#x6e;&#x67;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#109;">&#x6c;&#x73;&#46;&#x68;&#121;&#106;&#x69;&#x6e;&#x67;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#109;</a></li><li>School Email Address: <a href="mailto:&#x68;&#x6a;&#105;&#x6e;&#x67;&#55;&#x40;&#x77;&#x69;&#x73;&#99;&#x2e;&#x65;&#x64;&#x75;">&#x68;&#x6a;&#105;&#x6e;&#x67;&#55;&#x40;&#x77;&#x69;&#x73;&#99;&#x2e;&#x65;&#x64;&#x75;</a></li><li>Phone Number: (+1)9294269451 | (+86)13376173601</li><li>QQ id: 2595635885</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Nice-to-meet-you&quot;&gt;&lt;a href=&quot;#Nice-to-meet-you&quot; class=&quot;headerlink&quot; title=&quot;Nice to meet you&quot;&gt;&lt;/a&gt;Nice to meet you&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Im Light</summary>
      
    
    
    
    
  </entry>
  
</feed>
