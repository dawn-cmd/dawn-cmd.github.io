<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-mac-osx.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"dawn-cmd.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":true},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="中文版链接 AbstractIn computer science, Red-Black Trees are a type of self-balancing binary search tree that are used to store and retrieve elements in sorted order with O(log n) time complexity for all ma">
<meta property="og:type" content="article">
<meta property="og:title" content="Red Black Tree">
<meta property="og:url" content="https://dawn-cmd.github.io/2023/02/22/Red-Black-Tree/index.html">
<meta property="og:site_name" content="HuaiYuan_Jing">
<meta property="og:description" content="中文版链接 AbstractIn computer science, Red-Black Trees are a type of self-balancing binary search tree that are used to store and retrieve elements in sorted order with O(log n) time complexity for all ma">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://drive.google.com/uc?export=view&id=1uj8c9Md7JGe6XXoAX6HQEvo6oaGgzPHc">
<meta property="og:image" content="https://drive.google.com/uc?export=view&id=1ZgmVqbTb-yAB9iDVdC8rLuXuojKOPELT">
<meta property="article:published_time" content="2023-02-23T03:28:39.000Z">
<meta property="article:modified_time" content="2023-03-24T21:43:14.000Z">
<meta property="article:author" content="HuaiYuan_Jing">
<meta property="article:tag" content="data structure">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://drive.google.com/uc?export=view&id=1uj8c9Md7JGe6XXoAX6HQEvo6oaGgzPHc">

<link rel="canonical" href="https://dawn-cmd.github.io/2023/02/22/Red-Black-Tree/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Red Black Tree | HuaiYuan_Jing</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="HuaiYuan_Jing" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">HuaiYuan_Jing</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">HuaiYuan_Jing</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://dawn-cmd.github.io/2023/02/22/Red-Black-Tree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="HuaiYuan_Jing">
      <meta itemprop="description" content="Display Website">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HuaiYuan_Jing">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Red Black Tree
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-22 21:28:39" itemprop="dateCreated datePublished" datetime="2023-02-22T21:28:39-06:00">2023-02-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-24 16:43:14" itemprop="dateModified" datetime="2023-03-24T16:43:14-05:00">2023-03-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/data-structure-algorithm/" itemprop="url" rel="index"><span itemprop="name">data structure & algorithm</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><a href="https://dawn-cmd.github.io/2023/03/21/Red-Black-Tree-zh-CN/">中文版链接</a></p>
<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>In computer science, Red-Black Trees are a type of self-balancing binary search tree that are used to store and retrieve elements in sorted order with O(log n) time complexity for all major operations. They are designed to be memory-efficient and balanced, making them more efficient than other balanced trees like AVL trees. In this article, we have discussed the implementation of Red-Black Trees in Rust, a modern programming language designed for performance and safety. We have covered the structure of the tree, as well as the functions for insertion, deletion, and searching. Additionally, we have covered the fix functions that are used to restore the height balance and color balance properties of the tree after each insertion and deletion. Finally, we have discussed the left and right rotation functions that are used to maintain the balance properties of the Red-Black Tree. By using Rust to implement Red-Black Trees, we can take advantage of the language’s performance and safety features to create an efficient and reliable data structure.</p>
<h2 id="What-is-Red-Black-Tree-RBT"><a href="#What-is-Red-Black-Tree-RBT" class="headerlink" title="What is Red Black Tree (RBT)?"></a>What is Red Black Tree (RBT)?</h2><p>Red-Black Trees are binary search trees where each node is colored either red or black. The color of the node is used to balance the tree so that the longest path from the root to any leaf node is no more than twice as long as the shortest path from the root to any other leaf node. This property is known as the height balance property.</p>
<h2 id="Red-Black-Trees-are-constructed-with-the-following-rules"><a href="#Red-Black-Trees-are-constructed-with-the-following-rules" class="headerlink" title="Red-Black Trees are constructed with the following rules"></a>Red-Black Trees are constructed with the following rules</h2><ol>
<li>Each node is either red or black.</li>
<li>The root node is always black.</li>
<li>Every leaf (NIL) node is black.</li>
<li>If a node is red, then both its children must be black.</li>
<li>Every path from a given node to any of its descendant NIL nodes must contain the same number of black nodes.</li>
</ol>
<p>By assigning each node with a color and by limiting the number of consecutive colored nodes, RBT ensures that the longest branches will never exceed twice the size of the shortest branches, thus providing a more stable and effective tree. For reference, here’s a visual representation of an RBT:</p>
<p><img src="https://drive.google.com/uc?export=view&id=1uj8c9Md7JGe6XXoAX6HQEvo6oaGgzPHc" alt="photo_2023-02-22_21-58-43.jpg"></p>
<p>Here’s a comparison between BST and RBT when we insert “1, 2, 3, 4, 5” in order, demonstrating why RBT is far more efficient than BST when sorted elements are inserted:</p>
<p><img src="https://drive.google.com/uc?export=view&id=1ZgmVqbTb-yAB9iDVdC8rLuXuojKOPELT" alt="photo_2023-02-22_22-32-17.jpg"></p>
<p>Obviously, BST will become extremely low effective when receiving a sorted sequence. And RBT can become more balanced under this situation.</p>
<h2 id="Red-Black-Tree-Functions"><a href="#Red-Black-Tree-Functions" class="headerlink" title="Red-Black Tree Functions"></a>Red-Black Tree Functions</h2><p>A Red-Black Tree supports the following functions:</p>
<ol>
<li><p>Insertion: To insert a new node into the Red-Black Tree, we first create a new node with the given key and value. We then traverse the tree to find the correct location to insert the new node. If the tree is empty, we simply make the new node the root of the tree. If the tree is not empty, we compare the new node’s key to the key of the current node we are examining. If the new node’s key is less than the current node’s key, we move to the left child of the current node. If the new node’s key is greater than the current node’s key, we move to the right child of the current node. We repeat this process until we find an empty location in the tree where we can insert the new node.</p>
</li>
<li><p>Deletion: To delete a node from the Red-Black Tree, we first search for the node with the given key. If the node is not found, we simply return without doing anything. If the node is found, we replace it with its successor, which is the node with the smallest key in the node’s right subtree. We then delete the successor node from the tree using a similar process.</p>
</li>
<li><p>Searching: Searching for a node in the Red-Black Tree is similar to searching in a binary search tree. We start at the root node and compare the given key with the key of the current node. If the keys are equal, we return the value of the current node. If the given key is less than the key of the current node, we move to the left child. If the given key is greater than the key of the current node, we move to the right child. We repeat this process until we find the node with the given key or reach a leaf node.</p>
</li>
</ol>
<h2 id="Rust-Code-for-Red-Black-Trees"><a href="#Rust-Code-for-Red-Black-Trees" class="headerlink" title="Rust Code for Red-Black Trees"></a>Rust Code for Red-Black Trees</h2><p>To implement Red-Black Trees in Rust, we first define a Node struct to represent each node in the tree. The Node struct contains fields for the node’s key, value, color, and left and right children.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;   <span class="comment">// Defines an enum called &#x27;Color&#x27;</span></span><br><span class="line">    Red,      <span class="comment">// Enum variant representing the color red</span></span><br><span class="line">    Black,    <span class="comment">// Enum variant representing the color black</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&lt;K, V&gt; &#123;    <span class="comment">// Defines a struct called &#x27;Node&#x27; with generic parameters &#x27;K&#x27; and &#x27;V&#x27;</span></span><br><span class="line">    key: K,            <span class="comment">// Field representing the key of the node</span></span><br><span class="line">    value: V,          <span class="comment">// Field representing the value of the node</span></span><br><span class="line">    color: Color,      <span class="comment">// Field representing the color of the node, which is of type &#x27;Color&#x27; enum</span></span><br><span class="line">    left: <span class="type">Option</span>&lt;<span class="type">Box</span>&lt;Node&lt;K, V&gt;&gt;&gt;,   <span class="comment">// Field representing the left child node of the current node (if exists); it is an Option type and wrapped inside a box</span></span><br><span class="line">    right: <span class="type">Option</span>&lt;<span class="type">Box</span>&lt;Node&lt;K, V&gt;&gt;&gt;,  <span class="comment">// Field representing the right child node of the current node (if exists); it is an Option type and wrapped inside a box</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We also define an RBTree struct to represent the Red-Black Tree as a whole. The RBTree struct contains a root node and methods to insert, delete, and search for elements in the tree.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">RBTree</span>&lt;K: <span class="built_in">Ord</span>, V&gt; &#123;   <span class="comment">// Defines a struct called &#x27;RBTree&#x27; with generic parameters &#x27;K&#x27; and &#x27;V&#x27;; &#x27;K&#x27; must implement &#x27;Ord&#x27; trait</span></span><br><span class="line">    root: <span class="type">Option</span>&lt;<span class="type">Box</span>&lt;Node&lt;K, V&gt;&gt;&gt;,   <span class="comment">// Field representing the root node of the red-black tree; it is an Option type and wrapped inside a box</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Left-and-Right-Rotate"><a href="#Left-and-Right-Rotate" class="headerlink" title="Left and Right Rotate"></a>Left and Right Rotate</h3><p>These functions perform a left or right rotation of a given node and its children. The rotate_left function takes in a mutable reference to a node and rotates its right child to the left, while the rotate_right function takes in a mutable reference to a node and rotates its left child to the right.</p>
<p>During each rotation, the appropriate pointers are updated to reflect the new structure of the tree. The size of each node is also updated to reflect any changes that occurred during the rotation.</p>
<p>These rotation functions are used by the fix_after_insertion and fix_after_deletion methods to maintain the balance properties of the Red-Black Tree.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;K: <span class="built_in">Ord</span>, V&gt; RBTree&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Defines a private method called &#x27;rotate_left&#x27; that takes a mutable reference to a &#x27;Node&#x27; struct</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">rotate_left</span>(<span class="keyword">mut</span> node: &amp;<span class="keyword">mut</span> Node&lt;K, V&gt;) &#123;</span><br><span class="line">        <span class="comment">// Takes ownership of the right child node of the given node</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">right</span> = node.right.<span class="title function_ invoke__">take</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Moves the left child of the right child node to the right child of the given node</span></span><br><span class="line">        node.right = right.left.<span class="title function_ invoke__">take</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Sets the parent of the right child node as the given node and returns the right child node</span></span><br><span class="line">        right.left = <span class="title function_ invoke__">Some</span>(std::mem::<span class="title function_ invoke__">replace</span>(&amp;<span class="keyword">mut</span> node, right));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Sets the parent of the left child node of the given node to the given node</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(<span class="keyword">ref</span> <span class="keyword">mut</span> left) = node.left &#123;</span><br><span class="line">            left.parent = <span class="title function_ invoke__">Some</span>(node);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Sets the parent of the right child node of the given node to the given node</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(<span class="keyword">ref</span> <span class="keyword">mut</span> right) = node.right &#123;</span><br><span class="line">            right.parent = <span class="title function_ invoke__">Some</span>(node);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Updates the size of the given node</span></span><br><span class="line">        node.<span class="title function_ invoke__">update_size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Defines a private method called &#x27;rotate_right&#x27; that takes a mutable reference to a &#x27;Node&#x27; struct</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">rotate_right</span>(<span class="keyword">mut</span> node: &amp;<span class="keyword">mut</span> Node&lt;K, V&gt;) &#123;</span><br><span class="line">        <span class="comment">// Takes ownership of the left child node of the given node</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">left</span> = node.left.<span class="title function_ invoke__">take</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Moves the right child of the left child node to the left child of the given node</span></span><br><span class="line">        node.left = left.right.<span class="title function_ invoke__">take</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Sets the parent of the left child node as the given node and returns the left child node</span></span><br><span class="line">        left.right = <span class="title function_ invoke__">Some</span>(std::mem::<span class="title function_ invoke__">replace</span>(&amp;<span class="keyword">mut</span> node, left));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Sets the parent of the left child node of the given node to the given node</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(<span class="keyword">ref</span> <span class="keyword">mut</span> left) = node.left &#123;</span><br><span class="line">            left.parent = <span class="title function_ invoke__">Some</span>(node);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Sets the parent of the right child node of the given node to the given node</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(<span class="keyword">ref</span> <span class="keyword">mut</span> right) = node.right &#123;</span><br><span class="line">            right.parent = <span class="title function_ invoke__">Some</span>(node);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Updates the size of the given node</span></span><br><span class="line">        node.<span class="title function_ invoke__">update_size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Insertion-Function-in-Rust"><a href="#Insertion-Function-in-Rust" class="headerlink" title="Insertion Function in Rust"></a>Insertion Function in Rust</h3><p>The insert function in Rust follows the same logic as the insertion function described earlier. We create a new node with the given key and value and traverse the tree to find the correct location to insert the new node. If the tree is empty, we simply make the new node the root of the tree. If the tree is not empty, we compare the new node’s key to the key of the current node we are examining. If the new node’s key is less than the current node’s key, we move to the left child of the current node. If the new node’s key is greater than the current node’s key, we move to the right child of the current node. We repeat this process until we find an empty location in the tree where we can insert the new node.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;K: <span class="built_in">Ord</span>, V&gt; RBTree&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Defines a private method called &#x27;fix_after_insertion&#x27; that takes a mutable reference to a &#x27;Node&#x27; struct and an optional mutable reference to the root node</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fix_after_insertion</span>(</span><br><span class="line">        <span class="keyword">mut</span> node: &amp;<span class="keyword">mut</span> Node&lt;K, V&gt;,</span><br><span class="line">        root: <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> <span class="type">Box</span>&lt;Node&lt;K, V&gt;&gt;&gt;,</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="comment">// Sets the color of the inserted node as &#x27;Red&#x27;</span></span><br><span class="line">        node.color = Color::Red;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Checks if the node is not the root node and its parent&#x27;s color is &#x27;Red&#x27;</span></span><br><span class="line">        <span class="keyword">while</span> node != root.<span class="title function_ invoke__">unwrap</span>() &amp;&amp; node.<span class="title function_ invoke__">parent</span>().<span class="title function_ invoke__">unwrap</span>().color == Color::Red &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">parent</span> = node.<span class="title function_ invoke__">parent</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">grandparent</span> = node.<span class="title function_ invoke__">grandparent</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Checks if the parent is the left child of its grandparent</span></span><br><span class="line">            <span class="keyword">if</span> parent == grandparent.left.<span class="title function_ invoke__">as_ref</span>().<span class="title function_ invoke__">unwrap</span>() &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">uncle</span> = grandparent.right.<span class="title function_ invoke__">as_ref</span>();</span><br><span class="line">                <span class="comment">// Checks if the uncle node exists and its color is &#x27;Red&#x27;</span></span><br><span class="line">                <span class="keyword">if</span> uncle.<span class="title function_ invoke__">is_some</span>() &amp;&amp; uncle.<span class="title function_ invoke__">unwrap</span>().color == Color::Red &#123;</span><br><span class="line">                    <span class="comment">// Recolors the parent, uncle, and grandparent nodes, and sets the current node to its grandparent</span></span><br><span class="line">                    parent.color = Color::Black;</span><br><span class="line">                    uncle.<span class="title function_ invoke__">unwrap</span>().color = Color::Black;</span><br><span class="line">                    grandparent.color = Color::Red;</span><br><span class="line">                    node = grandparent;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Checks if the current node is the right child of its parent; if so, rotates it to the left around the parent node</span></span><br><span class="line">                    <span class="keyword">if</span> node == parent.right.<span class="title function_ invoke__">as_ref</span>().<span class="title function_ invoke__">unwrap</span>() &#123;</span><br><span class="line">                        node = parent;</span><br><span class="line">                        RBTree::<span class="title function_ invoke__">rotate_left</span>(parent);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// Recolors the parent and grandparent nodes, and rotates the grandparent node to the right</span></span><br><span class="line">                    parent.color = Color::Black;</span><br><span class="line">                    grandparent.color = Color::Red;</span><br><span class="line">                    RBTree::<span class="title function_ invoke__">rotate_right</span>(grandparent);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">uncle</span> = grandparent.left.<span class="title function_ invoke__">as_ref</span>();</span><br><span class="line">                <span class="comment">// Checks if the uncle node exists and its color is &#x27;Red&#x27;</span></span><br><span class="line">                <span class="keyword">if</span> uncle.<span class="title function_ invoke__">is_some</span>() &amp;&amp; uncle.<span class="title function_ invoke__">unwrap</span>().color == Color::Red &#123;</span><br><span class="line">                    <span class="comment">// Recolors the parent, uncle, and grandparent nodes, and sets the current node to its grandparent</span></span><br><span class="line">                    parent.color = Color::Black;</span><br><span class="line">                    uncle.<span class="title function_ invoke__">unwrap</span>().color = Color::Black;</span><br><span class="line">                    grandparent.color = Color::Red;</span><br><span class="line">                    node = grandparent;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Checks if the current node is the left child of its parent; if so, rotates it to the right around the parent node</span></span><br><span class="line">                    <span class="keyword">if</span> node == parent.left.<span class="title function_ invoke__">as_ref</span>().<span class="title function_ invoke__">unwrap</span>() &#123;</span><br><span class="line">                        node = parent;</span><br><span class="line">                        RBTree::<span class="title function_ invoke__">rotate_right</span>(parent);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// Recolors the parent and grandparent nodes, and rotates the grandparent node to the left</span></span><br><span class="line">                    parent.color = Color::Black;</span><br><span class="line">                    grandparent.color = Color::Red;</span><br><span class="line">                    RBTree::<span class="title function_ invoke__">rotate_left</span>(grandparent);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        root.<span class="title function_ invoke__">unwrap</span>().color = Color::Black;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Defines a public method called &#x27;insert&#x27; that takes a key and a value and adds it to the red-black tree</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">insert</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, key: K, value: V) &#123;</span><br><span class="line">        <span class="comment">// Creates a new node with the given key, value, and color &#x27;Red&#x27;</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">new_node</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Node &#123;</span><br><span class="line">            key,</span><br><span class="line">            value,</span><br><span class="line">            color: Color::Red,</span><br><span class="line">            left: <span class="literal">None</span>,</span><br><span class="line">            right: <span class="literal">None</span>,</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Checks if the root node exists</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(<span class="keyword">ref</span> <span class="keyword">mut</span> root) = <span class="keyword">self</span>.root &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">current</span> = root.<span class="title function_ invoke__">as_mut</span>();</span><br><span class="line">            <span class="comment">// Traverses through the tree until it finds a suitable place to insert the new node</span></span><br><span class="line">            <span class="keyword">loop</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> new_node.key &lt; current.key &#123;</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(<span class="keyword">ref</span> <span class="keyword">mut</span> left) = current.left &#123;</span><br><span class="line">                        current = left.<span class="title function_ invoke__">as_mut</span>();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        current.left = <span class="title function_ invoke__">Some</span>(new_node);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> new_node.key &gt; current.key &#123;</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(<span class="keyword">ref</span> <span class="keyword">mut</span> right) = current.right &#123;</span><br><span class="line">                        current = right.<span class="title function_ invoke__">as_mut</span>();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        current.right = <span class="title function_ invoke__">Some</span>(new_node);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// If the key already exists in the tree, updates its corresponding value and exits the loop</span></span><br><span class="line">                    current.value = new_node.value;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Fixes the tree after insertion of the new node</span></span><br><span class="line">            RBTree::<span class="title function_ invoke__">fix_after_insertion</span>(current, <span class="title function_ invoke__">Some</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.root));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// If the root node does not exist, sets the color of the new node as &#x27;Black&#x27; and makes it the root node</span></span><br><span class="line">            new_node.color = Color::Black;</span><br><span class="line">            <span class="keyword">self</span>.root = <span class="title function_ invoke__">Some</span>(new_node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Deletion-Function-in-Rust"><a href="#Deletion-Function-in-Rust" class="headerlink" title="Deletion Function in Rust"></a>Deletion Function in Rust</h3><p>The delete function in Rust also follows the same logic as the deletion function described earlier. We search for the node with the given key and replace it with its successor, which is the node with the smallest key in the node’s right subtree. We then delete the successor node from the tree using a similar process.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This function fixes the Red-Black Tree violations that may arise after a node deletion</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">fix_after_deletion</span>(</span><br><span class="line">    <span class="keyword">mut</span> node: &amp;<span class="keyword">mut</span> Node&lt;K, V&gt;,</span><br><span class="line">    root: <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> <span class="type">Box</span>&lt;Node&lt;K, V&gt;&gt;&gt;,</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">while</span> node != root.<span class="title function_ invoke__">unwrap</span>() &amp;&amp; node.color == Color::Black &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get the parent and sibling of the current node</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">parent</span> = node.<span class="title function_ invoke__">parent_mut</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">sibling</span> = node.<span class="title function_ invoke__">sibling</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> sibling.color == Color::Red &#123;</span><br><span class="line">            <span class="comment">// Case 1: The sibling of the current node is red</span></span><br><span class="line">            <span class="comment">// Change the colors of the parent, sibling, and the child of the sibling</span></span><br><span class="line">            sibling.color = Color::Black;</span><br><span class="line">            parent.color = Color::Red;</span><br><span class="line">            <span class="keyword">if</span> node.<span class="title function_ invoke__">is_left_child</span>() &#123;</span><br><span class="line">                <span class="comment">// Rotate left if the current node is the left child</span></span><br><span class="line">                RBTree::<span class="title function_ invoke__">rotate_left</span>(parent);</span><br><span class="line">                sibling.color = parent.right.<span class="title function_ invoke__">as_ref</span>().<span class="title function_ invoke__">unwrap</span>().color;</span><br><span class="line">                parent.right.<span class="title function_ invoke__">as_mut</span>().<span class="title function_ invoke__">unwrap</span>().color = Color::Black;</span><br><span class="line">                node = parent.left.<span class="title function_ invoke__">as_mut</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Rotate right if the current node is the right child</span></span><br><span class="line">                RBTree::<span class="title function_ invoke__">rotate_right</span>(parent);</span><br><span class="line">                sibling.color = parent.left.<span class="title function_ invoke__">as_ref</span>().<span class="title function_ invoke__">unwrap</span>().color;</span><br><span class="line">                parent.left.<span class="title function_ invoke__">as_mut</span>().<span class="title function_ invoke__">unwrap</span>().color = Color::Black;</span><br><span class="line">                node = parent.right.<span class="title function_ invoke__">as_mut</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> (<span class="title function_ invoke__">Some</span>(left), <span class="title function_ invoke__">Some</span>(right)) = (sibling.left.<span class="title function_ invoke__">as_ref</span>(), sibling.right.<span class="title function_ invoke__">as_ref</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> left.color == Color::Black &amp;&amp; right.color == Color::Black &#123;</span><br><span class="line">                    <span class="comment">// Case 2: The sibling of the current node is black and both its children are black</span></span><br><span class="line">                    <span class="comment">// Change the colors of the sibling and move up to the parent</span></span><br><span class="line">                    sibling.color = Color::Red;</span><br><span class="line">                    node = parent;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> node.<span class="title function_ invoke__">is_left_child</span>() &amp;&amp; right.color == Color::Black &#123;</span><br><span class="line">                        <span class="comment">// Case 3: The sibling of the current node is black and the right child is black</span></span><br><span class="line">                        <span class="comment">// Change the colors of the sibling and its left child, and rotate right</span></span><br><span class="line">                        sibling.color = Color::Red;</span><br><span class="line">                        left.color = Color::Black;</span><br><span class="line">                        RBTree::<span class="title function_ invoke__">rotate_right</span>(sibling);</span><br><span class="line">                        sibling = parent.right.<span class="title function_ invoke__">as_mut</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> node.<span class="title function_ invoke__">is_right_child</span>() &amp;&amp; left.color == Color::Black &#123;</span><br><span class="line">                        <span class="comment">// Case 3: The sibling of the current node is black and the left child is black</span></span><br><span class="line">                        <span class="comment">// Change the colors of the sibling and its right child, and rotate left</span></span><br><span class="line">                        sibling.color = Color::Red;</span><br><span class="line">                        right.color = Color::Black;</span><br><span class="line">                        RBTree::<span class="title function_ invoke__">rotate_left</span>(sibling);</span><br><span class="line">                        sibling = parent.left.<span class="title function_ invoke__">as_mut</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Case 4: The sibling of the current node is black and has a red child</span></span><br><span class="line">                    <span class="comment">// Change the colors of the parent, sibling, and the child of the sibling</span></span><br><span class="line">                    sibling.color = parent.color;</span><br><span class="line">                    parent.color = Color::Black;</span><br><span class="line">                    <span class="keyword">if</span> node.<span class="title function_ invoke__">is_left_child</span>() &#123;</span><br><span class="line">                        right.color = Color::Black;</span><br><span class="line">                        RBTree::<span class="title function_ invoke__">rotate_left</span>(parent);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        left.color = Color::Black;</span><br><span class="line">                        RBTree::<span class="title function_ invoke__">rotate_right</span>(parent);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Case 2: The sibling of the current node is black and has no children</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(left) = sibling.left.<span class="title function_ invoke__">as_ref</span>() &#123;</span><br><span class="line">                    <span class="keyword">if</span> node.<span class="title function_ invoke__">is_left_child</span>() &#123;</span><br><span class="line">                        <span class="comment">// Change the color of the sibling&#x27;s left child and rotate right</span></span><br><span class="line">                        left.color = Color::Black;</span><br><span class="line">                        sibling.color = parent.color;</span><br><span class="line">                        RBTree::<span class="title function_ invoke__">rotate_right</span>(parent);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// Change the color of the sibling and its left child, and rotate right</span></span><br><span class="line">                        left.color = Color::Red;</span><br><span class="line">                        RBTree::<span class="title function_ invoke__">rotate_right</span>(sibling);</span><br><span class="line">                        sibling = parent.right.<span class="title function_ invoke__">as_mut</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> node.<span class="title function_ invoke__">is_left_child</span>() &#123;</span><br><span class="line">                        <span class="comment">// Change the color of the sibling and its left child, and rotate right</span></span><br><span class="line">                        sibling.color = Color::Red;</span><br><span class="line">                        RBTree::<span class="title function_ invoke__">rotate_right</span>(sibling);</span><br><span class="line">                        sibling = parent.right.<span class="title function_ invoke__">as_mut</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// Change the colors of the parent and sibling, and rotate left</span></span><br><span class="line">                        sibling.color = parent.color;</span><br><span class="line">                        parent.color = Color::Black;</span><br><span class="line">                        RBTree::<span class="title function_ invoke__">rotate_left</span>(parent);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the color of the current node to black</span></span><br><span class="line">    node.color = Color::Black;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// This function deletes a node from the Red-Black Tree according to the given key</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">delete</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, key: &amp;K) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">current</span> = <span class="keyword">self</span>.root.<span class="title function_ invoke__">as_mut</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Some</span>(node) = current &#123;</span><br><span class="line">        <span class="keyword">if</span> key &lt; &amp;node.key &#123;</span><br><span class="line">            current = node.left.<span class="title function_ invoke__">as_mut</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> key &gt; &amp;node.key &#123;</span><br><span class="line">            current = node.right.<span class="title function_ invoke__">as_mut</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> node.left.<span class="title function_ invoke__">is_some</span>() &amp;&amp; node.right.<span class="title function_ invoke__">is_some</span>() &#123;</span><br><span class="line">                <span class="comment">// If the node has two children, replace it with its successor and delete the successor</span></span><br><span class="line">                <span class="keyword">let</span> <span class="variable">successor</span> = node.right.<span class="title function_ invoke__">as_mut</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">min_node</span>();</span><br><span class="line">                node.key = successor.key;</span><br><span class="line">                node.value = std::mem::<span class="title function_ invoke__">replace</span>(&amp;<span class="keyword">mut</span> successor.value, <span class="built_in">Default</span>::<span class="title function_ invoke__">default</span>());</span><br><span class="line">                current = <span class="title function_ invoke__">Some</span>(&amp;<span class="keyword">mut</span> *successor);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// If the node has one child or no children, remove it and fix any Red-Black Tree violations</span></span><br><span class="line">                <span class="keyword">let</span> <span class="variable">child</span> = <span class="keyword">if</span> node.left.<span class="title function_ invoke__">is_some</span>() &#123;</span><br><span class="line">                    node.left.<span class="title function_ invoke__">take</span>()</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    node.right.<span class="title function_ invoke__">take</span>()</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> node.color == Color::Black &#123;</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(<span class="keyword">ref</span> c) = child &#123;</span><br><span class="line">                        RBTree::<span class="title function_ invoke__">fix_after_deletion</span>(c.<span class="title function_ invoke__">as_mut</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.root));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        RBTree::<span class="title function_ invoke__">fix_after_deletion</span>(node, <span class="title function_ invoke__">Some</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.root));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="title function_ invoke__">Some</span>(node.value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="literal">None</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="Searching-Function-in-Rust"><a href="#Searching-Function-in-Rust" class="headerlink" title="Searching Function in Rust"></a>Searching Function in Rust</h3><p>The <code>search</code> function in Rust is also similar to the search function described earlier. We start at the root node and compare the given key with the key of the current node. If the keys are equal, we return the value of the current node. If the given key is less than the key of the current node, we move to the left child. If the given key is greater than the key of the current node, we move to the right child. We repeat this process until we find the node with the given key or reach a leaf node.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;K: <span class="built_in">Ord</span>, V&gt; RBTree&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">search</span>(&amp;<span class="keyword">self</span>, key: &amp;K) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;V&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">current</span> = <span class="keyword">self</span>.root.<span class="title function_ invoke__">as_ref</span>(); <span class="comment">// Start search from the root of the tree.</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Some</span>(node) = current &#123; <span class="comment">// Traverse the tree until the key is found or a leaf node is reached.</span></span><br><span class="line">            <span class="keyword">if</span> key == &amp;node.key &#123; <span class="comment">// If the key is found, return the corresponding value.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="title function_ invoke__">Some</span>(&amp;node.value);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> key &lt; &amp;node.key &#123; <span class="comment">// If the key is less than the current node&#x27;s key, search the left subtree.</span></span><br><span class="line">                current = node.left.<span class="title function_ invoke__">as_ref</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// If the key is greater than the current node&#x27;s key, search the right subtree.</span></span><br><span class="line">                current = node.right.<span class="title function_ invoke__">as_ref</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="literal">None</span> <span class="comment">// If the key is not found, return None.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Red-Black Trees are a type of self-balancing binary search tree that are used to store and retrieve elements in sorted order with O(log n) time complexity for all major operations. They are designed to be memory efficient and balanced, making them more efficient than other balanced trees like AVL trees. Rust is a modern programming language that is designed for performance and safety, making it a great choice for implementing data structures like the Red-Black Tree.</p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:  </strong>HuaiYuan_Jing
  </li>
  <li class="post-copyright-link">
    <strong>Post link: </strong>
    <a href="https://dawn-cmd.github.io/2023/02/22/Red-Black-Tree/" title="Red Black Tree">https://dawn-cmd.github.io/2023/02/22/Red-Black-Tree/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/en" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/data-structure/" rel="tag"># data structure</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2023/03/21/Red-Black-Tree-zh-CN/" rel="next" title="Red-Black-Tree(zh-CN)">
      Red-Black-Tree(zh-CN) <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Abstract"><span class="nav-number">1.</span> <span class="nav-text">Abstract</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#What-is-Red-Black-Tree-RBT"><span class="nav-number">2.</span> <span class="nav-text">What is Red Black Tree (RBT)?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Red-Black-Trees-are-constructed-with-the-following-rules"><span class="nav-number">3.</span> <span class="nav-text">Red-Black Trees are constructed with the following rules</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Red-Black-Tree-Functions"><span class="nav-number">4.</span> <span class="nav-text">Red-Black Tree Functions</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Rust-Code-for-Red-Black-Trees"><span class="nav-number">5.</span> <span class="nav-text">Rust Code for Red-Black Trees</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Left-and-Right-Rotate"><span class="nav-number">5.1.</span> <span class="nav-text">Left and Right Rotate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Insertion-Function-in-Rust"><span class="nav-number">5.2.</span> <span class="nav-text">Insertion Function in Rust</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Deletion-Function-in-Rust"><span class="nav-number">5.3.</span> <span class="nav-text">Deletion Function in Rust</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Searching-Function-in-Rust"><span class="nav-number">5.4.</span> <span class="nav-text">Searching Function in Rust</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Conclusion"><span class="nav-number">6.</span> <span class="nav-text">Conclusion</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">HuaiYuan_Jing</p>
  <div class="site-description" itemprop="description">Display Website</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/en" class="cc-opacity" rel="external nofollow noopener noreferrer" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">HuaiYuan_Jing</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>
    <script defer src="/lib/three/canvas_sphere.min.js"></script>


  




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script>
<script src="/js/algolia-search.js"></script>














  

  

</body>
</html>
