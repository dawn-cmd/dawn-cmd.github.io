<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    
    <title>Red-Black-Tree(zh-CN) | LightString</title>
    
    
        <meta name="keywords" content="data structure">
    
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="English Version 摘要红黑树是一种自平衡的二叉搜索树，用于按排序顺序存储和检索元素，并具有O（log n）时间复杂度的所有主要操作。它们被设计为内存高效和平衡，使它们比其他平衡树如AVL树更高效。在本文中，我们讨论了在Rust中实现红黑树，这是一种为性能和安全性而设计的现代编程语言。我们讨论了树的结构，以及插入，删除和搜索的函数。此外，我们还讨论了修复函数，用于在每次插入和删除后恢复">
<meta property="og:type" content="article">
<meta property="og:title" content="Red-Black-Tree(zh-CN)">
<meta property="og:url" content="http://example.com/2023/03/21/Red-Black-Tree-zh-CN/index.html">
<meta property="og:site_name" content="LightString">
<meta property="og:description" content="English Version 摘要红黑树是一种自平衡的二叉搜索树，用于按排序顺序存储和检索元素，并具有O（log n）时间复杂度的所有主要操作。它们被设计为内存高效和平衡，使它们比其他平衡树如AVL树更高效。在本文中，我们讨论了在Rust中实现红黑树，这是一种为性能和安全性而设计的现代编程语言。我们讨论了树的结构，以及插入，删除和搜索的函数。此外，我们还讨论了修复函数，用于在每次插入和删除后恢复">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://drive.google.com/uc?export=view&id=1uj8c9Md7JGe6XXoAX6HQEvo6oaGgzPHc">
<meta property="og:image" content="https://drive.google.com/uc?export=view&id=1ZgmVqbTb-yAB9iDVdC8rLuXuojKOPELT">
<meta property="article:published_time" content="2023-03-21T16:40:46.000Z">
<meta property="article:modified_time" content="2023-03-22T01:35:35.988Z">
<meta property="article:author" content="LightString">
<meta property="article:tag" content="data structure">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://drive.google.com/uc?export=view&id=1uj8c9Md7JGe6XXoAX6HQEvo6oaGgzPHc">
    

    
        <link rel="alternate" href="/atom.xml" title="LightString" type="application/atom+xml">
    

    
        <link rel="icon" href="/icon.png">
    

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/libs/open-sans/styles.css">

    
<link rel="stylesheet" href="/libs/source-code-pro/styles.css">


    
<link rel="stylesheet" href="/css/style.css">

    
<script src="/libs/jquery/2.1.3/jquery.min.js"></script>

    
<script src="/libs/jquery/plugins/cookie/1.4.1/jquery.cookie.js"></script>

    
    
        
<link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">

    
    
        
<link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">

    
    
    
    


    
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
    <div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                <i class="logo"></i>
                <span class="site-title">LightString</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/">HomePage</a>
                
                    <a class="main-nav-link" href="/archives">Archives</a>
                
                    <a class="main-nav-link" href="/categories">Categories</a>
                
                    <a class="main-nav-link" href="/tags">Tags</a>
                
                    <a class="main-nav-link" href="/about">About</a>
                
                    <a class="main-nav-link" href="/links">Links</a>
                
            </nav>
            
            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="Search">
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something...">
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>


</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/">HomePage</a></td>
                
                    <td><a class="main-nav-link" href="/archives">Archives</a></td>
                
                    <td><a class="main-nav-link" href="/categories">Categories</a></td>
                
                    <td><a class="main-nav-link" href="/tags">Tags</a></td>
                
                    <td><a class="main-nav-link" href="/about">About</a></td>
                
                    <td><a class="main-nav-link" href="/links">Links</a></td>
                
                <td>
                    
    <div class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="Search">
    </div>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            
            
                <aside id="sidebar">
   
        
    <div class="widget-wrap" id="categories">
        <h3 class="widget-title">
            <span>categories</span>
            &nbsp;
            <a id="allExpand" href="#">
                <i class="fa fa-angle-double-down fa-2x"></i>
            </a>
        </h3>
        
        
        
         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            applications
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/2023/03/24/A-Multifaceted-Translation-Tool-Integrating-GPT-3-5-Turbo-and-Wox-for-Seamless-Language-Processing/">A Multifaceted Translation Tool: Integrating GPT-3.5 Turbo and Wox for Seamless Language Processing</a></li>  <li class="file"><a href="/2023/03/24/A-Multifaceted-Translation-Tool-Integrating-GPT-3-5-Turbo-and-Wox-for-Seamless-Language-Processing-zh-CN/">A Multifaceted Translation Tool: Integrating GPT-3.5 Turbo and Wox for Seamless Language Processing(zh-CN)</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory open">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder-open"></i>
                            &nbsp;
                            data structure & algorithm
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/2023/02/22/Red-Black-Tree/">Red Black Tree</a></li>  <li class="file active"><a href="/2023/03/21/Red-Black-Tree-zh-CN/">Red-Black-Tree(zh-CN)</a></li>  </ul> 
                    </li> 
                     <li class="file"><a href="/2023/02/13/SelfDescription/">Self Description</a></li>  </ul> 
    </div>
    <script>
        $(document).ready(function() {
            var iconFolderOpenClass  = 'fa-folder-open';
            var iconFolderCloseClass = 'fa-folder';
            var iconAllExpandClass = 'fa-angle-double-down';
            var iconAllPackClass = 'fa-angle-double-up';
            // Handle directory-tree expansion:
            // 左键单独展开目录
            $(document).on('click', '#categories a[data-role="directory"]', function (event) {
                event.preventDefault();

                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconFolderOpenClass);
                var subtree = $(this).siblings('ul');
                icon.removeClass(iconFolderOpenClass).removeClass(iconFolderCloseClass);
                if (expanded) {
                    if (typeof subtree != 'undefined') {
                        subtree.slideUp({ duration: 100 });
                    }
                    icon.addClass(iconFolderCloseClass);
                } else {
                    if (typeof subtree != 'undefined') {
                        subtree.slideDown({ duration: 100 });
                    }
                    icon.addClass(iconFolderOpenClass);
                }
            });
            // 右键展开下属所有目录
            $('#categories a[data-role="directory"]').bind("contextmenu", function(event){
                event.preventDefault();
                
                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconFolderOpenClass);
                var listNode = $(this).siblings('ul');
                var subtrees = $.merge(listNode.find('li ul'), listNode);
                var icons = $.merge(listNode.find('.fa'), icon);
                icons.removeClass(iconFolderOpenClass).removeClass(iconFolderCloseClass);
                if(expanded) {
                    subtrees.slideUp({ duration: 100 });
                    icons.addClass(iconFolderCloseClass);
                } else {
                    subtrees.slideDown({ duration: 100 });
                    icons.addClass(iconFolderOpenClass);
                }
            })
            // 展开关闭所有目录按钮
            $(document).on('click', '#allExpand', function (event) {
                event.preventDefault();
                
                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconAllExpandClass);
                icon.removeClass(iconAllExpandClass).removeClass(iconAllPackClass);
                if(expanded) {
                    $('#sidebar .fa.fa-folder').removeClass('fa-folder').addClass('fa-folder-open')
                    $('#categories li ul').slideDown({ duration: 100 });
                    icon.addClass(iconAllPackClass);
                } else {
                    $('#sidebar .fa.fa-folder-open').removeClass('fa-folder-open').addClass('fa-folder')
                    $('#categories li ul').slideUp({ duration: 100 });
                    icon.addClass(iconAllExpandClass);
                }
            });  
        });
    </script>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title"><span>tag cloud</span></h3>
        <div class="widget tagcloud">
            <a href="/tags/data-structure/" style="font-size: 10px;">data structure</a> <a href="/tags/openAI/" style="font-size: 10px;">openAI</a>
        </div>
    </div>

    
    <div id="toTop" class="fa fa-angle-up"></div>
</aside>
            
            <section id="main"><article id="post-Red-Black-Tree-zh-CN" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/data-structure-algorithm/">data structure & algorithm</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link-link" href="/tags/data-structure/" rel="tag">data structure</a>
    </div>

                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2023/03/21/Red-Black-Tree-zh-CN/">
            <time datetime="2023-03-21T16:40:46.000Z" itemprop="datePublished">2023-03-21</time>
        </a>
    </div>


                        
                            <i class="fa fa-bar-chart"></i>
                            <span id="busuanzi_container_site_pv"><span id="busuanzi_value_page_pv"></span></span>    
                        
                        
                            <div class="article-meta-button">
                                <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/dawn-cmd/dawn-cmd.github.io/raw/writing/source/_posts/Red-Black-Tree-zh-CN.md"> Source </a>
                            </div>
                            <div class="article-meta-button">
                                <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/dawn-cmd/dawn-cmd.github.io/edit/writing/source/_posts/Red-Black-Tree-zh-CN.md"> Edit </a>
                            </div>
                            <div class="article-meta-button">
                                <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/dawn-cmd/dawn-cmd.github.io/commits/writing/source/_posts/Red-Black-Tree-zh-CN.md"> History </a>
                            </div>
                        
                    </div>
                
                
    
        <h1 class="article-title" itemprop="name">
            Red-Black-Tree(zh-CN)
        </h1>
    

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
                <div id="toc" class="toc-article">
                <strong class="toc-title">Catalogue</strong>
                    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%91%98%E8%A6%81"><span class="toc-number">1.</span> <span class="toc-text">摘要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%88RBT%EF%BC%89%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">什么是红黑树（RBT）？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E6%98%AF%E6%8C%89%E7%85%A7%E4%BB%A5%E4%B8%8B%E8%A7%84%E5%88%99%E6%9E%84%E5%BB%BA%E7%9A%84"><span class="toc-number">3.</span> <span class="toc-text">红黑树是按照以下规则构建的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E5%87%BD%E6%95%B0"><span class="toc-number">4.</span> <span class="toc-text">红黑树函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Rust%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E4%BB%A3%E7%A0%81"><span class="toc-number">5.</span> <span class="toc-text">Rust中的红黑树代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E6%97%8B%E5%92%8C%E5%8F%B3%E6%97%8B"><span class="toc-number">5.1.</span> <span class="toc-text">左旋和右旋</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E5%87%BD%E6%95%B0"><span class="toc-number">5.2.</span> <span class="toc-text">插入函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%87%BD%E6%95%B0"><span class="toc-number">5.3.</span> <span class="toc-text">删除函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E5%87%BD%E6%95%B0"><span class="toc-number">5.4.</span> <span class="toc-text">搜索函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-number">6.</span> <span class="toc-text">结论</span></a></li></ol>
                </div>
            
        
        
            <p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://dawn-cmd.github.io/2023/02/22/Red-Black-Tree/">English Version</a></p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>红黑树是一种自平衡的二叉搜索树，用于按排序顺序存储和检索元素，并具有O（log n）时间复杂度的所有主要操作。它们被设计为内存高效和平衡，使它们比其他平衡树如AVL树更高效。在本文中，我们讨论了在Rust中实现红黑树，这是一种为性能和安全性而设计的现代编程语言。我们讨论了树的结构，以及插入，删除和搜索的函数。此外，我们还讨论了修复函数，用于在每次插入和删除后恢复树的高度平衡和颜色平衡属性。最后，我们讨论了左旋和右旋函数，用于维护红黑树的平衡属性。通过使用Rust来实现红黑树，我们可以利用该语言的性能和安全性功能来创建高效且可靠的数据结构。</p>
<h2 id="什么是红黑树（RBT）？"><a href="#什么是红黑树（RBT）？" class="headerlink" title="什么是红黑树（RBT）？"></a>什么是红黑树（RBT）？</h2><p>红黑树是一种二叉搜索树，其中每个节点都被着色为红色或黑色。节点的颜色用于平衡树，以使从根节点到任何叶子节点的最长路径不超过从根节点到任何其他叶子节点的最短路径的两倍。此属性称为高度平衡属性。</p>
<h2 id="红黑树是按照以下规则构建的"><a href="#红黑树是按照以下规则构建的" class="headerlink" title="红黑树是按照以下规则构建的"></a>红黑树是按照以下规则构建的</h2><ol>
<li>每个节点都是红色或黑色。</li>
<li>根节点始终为黑色。</li>
<li>每个叶子（NIL）节点都是黑色的。</li>
<li>如果一个节点为红色，则它的两个子节点必须为黑色。</li>
<li>从给定节点到其任何后代NIL节点的每条路径必须包含相同数量的黑色节点。</li>
</ol>
<p>通过为每个节点分配颜色并限制连续的着色节点数量，RBT确保最长的分支永远不会超过最短分支的两倍大小，从而提供更稳定和有效的树。</p>
<p>以下是RBT的视觉表示：</p>
<p><img src="https://drive.google.com/uc?export=view&id=1uj8c9Md7JGe6XXoAX6HQEvo6oaGgzPHc" alt="photo_2023-02-22_21-58-43.jpg"></p>
<p>当我们按顺序插入“1, 2, 3, 4, 5”时，以下是BST和RBT之间的比较，展示了为什么在插入排序元素时RBT远比BST有效：</p>
<p><img src="https://drive.google.com/uc?export=view&id=1ZgmVqbTb-yAB9iDVdC8rLuXuojKOPELT" alt="photo_2023-02-22_22-32-17.jpg"></p>
<p>很明显，当收到排序序列时，BST将变得非常低效。而RBT在此情况下可以更加平衡。</p>
<h2 id="红黑树函数"><a href="#红黑树函数" class="headerlink" title="红黑树函数"></a>红黑树函数</h2><p>红黑树支持以下函数：</p>
<ol>
<li><p>插入：要将新节点插入红黑树中，我们首先创建一个具有给定键和值的新节点。然后，我们遍历树以找到插入新节点的正确位置。如果树为空，我们将新节点简单地作为树的根。如果树不为空，我们将新节点的键与当前正在检查的节点的键进行比较。如果新节点的键小于当前节点的键，则移动到当前节点的左子节点。如果新节点的键大于当前节点的键，则移动到当前节点的右子节点。我们重复这个过程，直到我们找到一个可以插入新节点的空位置。</p>
</li>
<li><p>删除：要从红黑树中删除节点，我们首先搜索具有给定键的节点。如果找不到节点，我们简单地返回而不做任何事情。如果找到节点，我们用其后继节点替换它，后继节点是节点右子树中键值最小的节点。然后，我们使用类似的过程从树中删除后继节点。</p>
</li>
<li><p>搜索：在红黑树中搜索节点类似于在二叉搜索树中搜索。我们从根节点开始，将给定键与当前节点的键进行比较。如果键相等，我们返回当前节点的值。如果给定键小于当前节点的键，我们移动到左子节点。如果给定键大于当前节点的键，则移动到右子节点。我们重复这个过程，直到我们找到具有给定键的节点或到达叶子节点。</p>
</li>
</ol>
<h2 id="Rust中的红黑树代码"><a href="#Rust中的红黑树代码" class="headerlink" title="Rust中的红黑树代码"></a>Rust中的红黑树代码</h2><p>要在Rust中实现红黑树，我们首先定义一个Node结构来表示树中的每个节点。Node结构包含节点的键，值，颜色和左右子节点字段。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;   <span class="comment">// Defines an enum called &#x27;Color&#x27;</span></span><br><span class="line">    Red,      <span class="comment">// Enum variant representing the color red</span></span><br><span class="line">    Black,    <span class="comment">// Enum variant representing the color black</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&lt;K, V&gt; &#123;    <span class="comment">// Defines a struct called &#x27;Node&#x27; with generic parameters &#x27;K&#x27; and &#x27;V&#x27;</span></span><br><span class="line">    key: K,            <span class="comment">// Field representing the key of the node</span></span><br><span class="line">    value: V,          <span class="comment">// Field representing the value of the node</span></span><br><span class="line">    color: Color,      <span class="comment">// Field representing the color of the node, which is of type &#x27;Color&#x27; enum</span></span><br><span class="line">    left: <span class="type">Option</span>&lt;<span class="type">Box</span>&lt;Node&lt;K, V&gt;&gt;&gt;,   <span class="comment">// Field representing the left child node of the current node (if exists); it is an Option type and wrapped inside a box</span></span><br><span class="line">    right: <span class="type">Option</span>&lt;<span class="type">Box</span>&lt;Node&lt;K, V&gt;&gt;&gt;,  <span class="comment">// Field representing the right child node of the current node (if exists); it is an Option type and wrapped inside a box</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还定义了一个RBTree结构来表示整个红黑树。RBTree结构包含一个根节点和用于插入，删除和搜索树中元素的方法。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">RBTree</span>&lt;K: <span class="built_in">Ord</span>, V&gt; &#123;   <span class="comment">// Defines a struct called &#x27;RBTree&#x27; with generic parameters &#x27;K&#x27; and &#x27;V&#x27;; &#x27;K&#x27; must implement &#x27;Ord&#x27; trait</span></span><br><span class="line">    root: <span class="type">Option</span>&lt;<span class="type">Box</span>&lt;Node&lt;K, V&gt;&gt;&gt;,   <span class="comment">// Field representing the root node of the red-black tree; it is an Option type and wrapped inside a box</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="左旋和右旋"><a href="#左旋和右旋" class="headerlink" title="左旋和右旋"></a>左旋和右旋</h3><p>这些函数执行给定节点及其子节点的左旋或右旋操作。rotate_left函数接收一个可变引用到一个节点，并将其右子节点向左旋转，而rotate_right函数接收一个可变引用到一个节点，并将其左子节点向右旋转。</p>
<p>在每次旋转期间，适当的指针被更新以反映树的新结构。每个节点的大小也被更新以反映旋转过程中发生的任何更改。</p>
<p>这些旋转函数由fix_after_insertion和fix_after_deletion方法用于维护红黑树的平衡属性。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;K: <span class="built_in">Ord</span>, V&gt; RBTree&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Defines a private method called &#x27;rotate_left&#x27; that takes a mutable reference to a &#x27;Node&#x27; struct</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">rotate_left</span>(<span class="keyword">mut</span> node: &amp;<span class="keyword">mut</span> Node&lt;K, V&gt;) &#123;</span><br><span class="line">        <span class="comment">// Takes ownership of the right child node of the given node</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">right</span> = node.right.<span class="title function_ invoke__">take</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Moves the left child of the right child node to the right child of the given node</span></span><br><span class="line">        node.right = right.left.<span class="title function_ invoke__">take</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Sets the parent of the right child node as the given node and returns the right child node</span></span><br><span class="line">        right.left = <span class="title function_ invoke__">Some</span>(std::mem::<span class="title function_ invoke__">replace</span>(&amp;<span class="keyword">mut</span> node, right));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Sets the parent of the left child node of the given node to the given node</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(<span class="keyword">ref</span> <span class="keyword">mut</span> left) = node.left &#123;</span><br><span class="line">            left.parent = <span class="title function_ invoke__">Some</span>(node);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Sets the parent of the right child node of the given node to the given node</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(<span class="keyword">ref</span> <span class="keyword">mut</span> right) = node.right &#123;</span><br><span class="line">            right.parent = <span class="title function_ invoke__">Some</span>(node);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Updates the size of the given node</span></span><br><span class="line">        node.<span class="title function_ invoke__">update_size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Defines a private method called &#x27;rotate_right&#x27; that takes a mutable reference to a &#x27;Node&#x27; struct</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">rotate_right</span>(<span class="keyword">mut</span> node: &amp;<span class="keyword">mut</span> Node&lt;K, V&gt;) &#123;</span><br><span class="line">        <span class="comment">// Takes ownership of the left child node of the given node</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">left</span> = node.left.<span class="title function_ invoke__">take</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Moves the right child of the left child node to the left child of the given node</span></span><br><span class="line">        node.left = left.right.<span class="title function_ invoke__">take</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Sets the parent of the left child node as the given node and returns the left child node</span></span><br><span class="line">        left.right = <span class="title function_ invoke__">Some</span>(std::mem::<span class="title function_ invoke__">replace</span>(&amp;<span class="keyword">mut</span> node, left));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Sets the parent of the left child node of the given node to the given node</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(<span class="keyword">ref</span> <span class="keyword">mut</span> left) = node.left &#123;</span><br><span class="line">            left.parent = <span class="title function_ invoke__">Some</span>(node);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Sets the parent of the right child node of the given node to the given node</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(<span class="keyword">ref</span> <span class="keyword">mut</span> right) = node.right &#123;</span><br><span class="line">            right.parent = <span class="title function_ invoke__">Some</span>(node);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Updates the size of the given node</span></span><br><span class="line">        node.<span class="title function_ invoke__">update_size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="插入函数"><a href="#插入函数" class="headerlink" title="插入函数"></a>插入函数</h3><p>插入函数遵循之前描述的插入函数相同的逻辑。我们创建一个具有给定键和值的新节点，并遍历树以找到插入新节点的正确位置。如果树为空，我们将新节点简单地作为树的根。如果树不为空，我们将新节点的键与当前正在检查的节点的键进行比较。如果新节点的键小于当前节点的键，则移动到当前节点的左子节点。如果新节点的键大于当前节点的键，则移动到当前节点的右子节点。我们重复这个过程，直到我们找到一个可以插入新节点的空位置。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;K: <span class="built_in">Ord</span>, V&gt; RBTree&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Defines a private method called &#x27;fix_after_insertion&#x27; that takes a mutable reference to a &#x27;Node&#x27; struct and an optional mutable reference to the root node</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fix_after_insertion</span>(</span><br><span class="line">        <span class="keyword">mut</span> node: &amp;<span class="keyword">mut</span> Node&lt;K, V&gt;,</span><br><span class="line">        root: <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> <span class="type">Box</span>&lt;Node&lt;K, V&gt;&gt;&gt;,</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="comment">// Sets the color of the inserted node as &#x27;Red&#x27;</span></span><br><span class="line">        node.color = Color::Red;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Checks if the node is not the root node and its parent&#x27;s color is &#x27;Red&#x27;</span></span><br><span class="line">        <span class="keyword">while</span> node != root.<span class="title function_ invoke__">unwrap</span>() &amp;&amp; node.<span class="title function_ invoke__">parent</span>().<span class="title function_ invoke__">unwrap</span>().color == Color::Red &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">parent</span> = node.<span class="title function_ invoke__">parent</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">grandparent</span> = node.<span class="title function_ invoke__">grandparent</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Checks if the parent is the left child of its grandparent</span></span><br><span class="line">            <span class="keyword">if</span> parent == grandparent.left.<span class="title function_ invoke__">as_ref</span>().<span class="title function_ invoke__">unwrap</span>() &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">uncle</span> = grandparent.right.<span class="title function_ invoke__">as_ref</span>();</span><br><span class="line">                <span class="comment">// Checks if the uncle node exists and its color is &#x27;Red&#x27;</span></span><br><span class="line">                <span class="keyword">if</span> uncle.<span class="title function_ invoke__">is_some</span>() &amp;&amp; uncle.<span class="title function_ invoke__">unwrap</span>().color == Color::Red &#123;</span><br><span class="line">                    <span class="comment">// Recolors the parent, uncle, and grandparent nodes, and sets the current node to its grandparent</span></span><br><span class="line">                    parent.color = Color::Black;</span><br><span class="line">                    uncle.<span class="title function_ invoke__">unwrap</span>().color = Color::Black;</span><br><span class="line">                    grandparent.color = Color::Red;</span><br><span class="line">                    node = grandparent;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Checks if the current node is the right child of its parent; if so, rotates it to the left around the parent node</span></span><br><span class="line">                    <span class="keyword">if</span> node == parent.right.<span class="title function_ invoke__">as_ref</span>().<span class="title function_ invoke__">unwrap</span>() &#123;</span><br><span class="line">                        node = parent;</span><br><span class="line">                        RBTree::<span class="title function_ invoke__">rotate_left</span>(parent);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// Recolors the parent and grandparent nodes, and rotates the grandparent node to the right</span></span><br><span class="line">                    parent.color = Color::Black;</span><br><span class="line">                    grandparent.color = Color::Red;</span><br><span class="line">                    RBTree::<span class="title function_ invoke__">rotate_right</span>(grandparent);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">uncle</span> = grandparent.left.<span class="title function_ invoke__">as_ref</span>();</span><br><span class="line">                <span class="comment">// Checks if the uncle node exists and its color is &#x27;Red&#x27;</span></span><br><span class="line">                <span class="keyword">if</span> uncle.<span class="title function_ invoke__">is_some</span>() &amp;&amp; uncle.<span class="title function_ invoke__">unwrap</span>().color == Color::Red &#123;</span><br><span class="line">                    <span class="comment">// Recolors the parent, uncle, and grandparent nodes, and sets the current node to its grandparent</span></span><br><span class="line">                    parent.color = Color::Black;</span><br><span class="line">                    uncle.<span class="title function_ invoke__">unwrap</span>().color = Color::Black;</span><br><span class="line">                    grandparent.color = Color::Red;</span><br><span class="line">                    node = grandparent;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Checks if the current node is the left child of its parent; if so, rotates it to the right around the parent node</span></span><br><span class="line">                    <span class="keyword">if</span> node == parent.left.<span class="title function_ invoke__">as_ref</span>().<span class="title function_ invoke__">unwrap</span>() &#123;</span><br><span class="line">                        node = parent;</span><br><span class="line">                        RBTree::<span class="title function_ invoke__">rotate_right</span>(parent);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// Recolors the parent and grandparent nodes, and rotates the grandparent node to the left</span></span><br><span class="line">                    parent.color = Color::Black;</span><br><span class="line">                    grandparent.color = Color::Red;</span><br><span class="line">                    RBTree::<span class="title function_ invoke__">rotate_left</span>(grandparent);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        root.<span class="title function_ invoke__">unwrap</span>().color = Color::Black;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Defines a public method called &#x27;insert&#x27; that takes a key and a value and adds it to the red-black tree</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">insert</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, key: K, value: V) &#123;</span><br><span class="line">        <span class="comment">// Creates a new node with the given key, value, and color &#x27;Red&#x27;</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">new_node</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Node &#123;</span><br><span class="line">            key,</span><br><span class="line">            value,</span><br><span class="line">            color: Color::Red,</span><br><span class="line">            left: <span class="literal">None</span>,</span><br><span class="line">            right: <span class="literal">None</span>,</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Checks if the root node exists</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(<span class="keyword">ref</span> <span class="keyword">mut</span> root) = <span class="keyword">self</span>.root &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">current</span> = root.<span class="title function_ invoke__">as_mut</span>();</span><br><span class="line">            <span class="comment">// Traverses through the tree until it finds a suitable place to insert the new node</span></span><br><span class="line">            <span class="keyword">loop</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> new_node.key &lt; current.key &#123;</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(<span class="keyword">ref</span> <span class="keyword">mut</span> left) = current.left &#123;</span><br><span class="line">                        current = left.<span class="title function_ invoke__">as_mut</span>();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        current.left = <span class="title function_ invoke__">Some</span>(new_node);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> new_node.key &gt; current.key &#123;</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(<span class="keyword">ref</span> <span class="keyword">mut</span> right) = current.right &#123;</span><br><span class="line">                        current = right.<span class="title function_ invoke__">as_mut</span>();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        current.right = <span class="title function_ invoke__">Some</span>(new_node);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// If the key already exists in the tree, updates its corresponding value and exits the loop</span></span><br><span class="line">                    current.value = new_node.value;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Fixes the tree after insertion of the new node</span></span><br><span class="line">            RBTree::<span class="title function_ invoke__">fix_after_insertion</span>(current, <span class="title function_ invoke__">Some</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.root));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// If the root node does not exist, sets the color of the new node as &#x27;Black&#x27; and makes it the root node</span></span><br><span class="line">            new_node.color = Color::Black;</span><br><span class="line">            <span class="keyword">self</span>.root = <span class="title function_ invoke__">Some</span>(new_node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<h3 id="删除函数"><a href="#删除函数" class="headerlink" title="删除函数"></a>删除函数</h3><p>删除函数也遵循之前描述的删除函数相同的逻辑。我们搜索具有给定键的节点，并用其后继节点替换它，后继节点是节点右子树中键值最小的节点。然后，我们使用类似的过程从树中删除后继节点。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This function fixes the Red-Black Tree violations that may arise after a node deletion</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">fix_after_deletion</span>(</span><br><span class="line">    <span class="keyword">mut</span> node: &amp;<span class="keyword">mut</span> Node&lt;K, V&gt;,</span><br><span class="line">    root: <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> <span class="type">Box</span>&lt;Node&lt;K, V&gt;&gt;&gt;,</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">while</span> node != root.<span class="title function_ invoke__">unwrap</span>() &amp;&amp; node.color == Color::Black &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get the parent and sibling of the current node</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">parent</span> = node.<span class="title function_ invoke__">parent_mut</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">sibling</span> = node.<span class="title function_ invoke__">sibling</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> sibling.color == Color::Red &#123;</span><br><span class="line">            <span class="comment">// Case 1: The sibling of the current node is red</span></span><br><span class="line">            <span class="comment">// Change the colors of the parent, sibling, and the child of the sibling</span></span><br><span class="line">            sibling.color = Color::Black;</span><br><span class="line">            parent.color = Color::Red;</span><br><span class="line">            <span class="keyword">if</span> node.<span class="title function_ invoke__">is_left_child</span>() &#123;</span><br><span class="line">                <span class="comment">// Rotate left if the current node is the left child</span></span><br><span class="line">                RBTree::<span class="title function_ invoke__">rotate_left</span>(parent);</span><br><span class="line">                sibling.color = parent.right.<span class="title function_ invoke__">as_ref</span>().<span class="title function_ invoke__">unwrap</span>().color;</span><br><span class="line">                parent.right.<span class="title function_ invoke__">as_mut</span>().<span class="title function_ invoke__">unwrap</span>().color = Color::Black;</span><br><span class="line">                node = parent.left.<span class="title function_ invoke__">as_mut</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Rotate right if the current node is the right child</span></span><br><span class="line">                RBTree::<span class="title function_ invoke__">rotate_right</span>(parent);</span><br><span class="line">                sibling.color = parent.left.<span class="title function_ invoke__">as_ref</span>().<span class="title function_ invoke__">unwrap</span>().color;</span><br><span class="line">                parent.left.<span class="title function_ invoke__">as_mut</span>().<span class="title function_ invoke__">unwrap</span>().color = Color::Black;</span><br><span class="line">                node = parent.right.<span class="title function_ invoke__">as_mut</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> (<span class="title function_ invoke__">Some</span>(left), <span class="title function_ invoke__">Some</span>(right)) = (sibling.left.<span class="title function_ invoke__">as_ref</span>(), sibling.right.<span class="title function_ invoke__">as_ref</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> left.color == Color::Black &amp;&amp; right.color == Color::Black &#123;</span><br><span class="line">                    <span class="comment">// Case 2: The sibling of the current node is black and both its children are black</span></span><br><span class="line">                    <span class="comment">// Change the colors of the sibling and move up to the parent</span></span><br><span class="line">                    sibling.color = Color::Red;</span><br><span class="line">                    node = parent;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> node.<span class="title function_ invoke__">is_left_child</span>() &amp;&amp; right.color == Color::Black &#123;</span><br><span class="line">                        <span class="comment">// Case 3: The sibling of the current node is black and the right child is black</span></span><br><span class="line">                        <span class="comment">// Change the colors of the sibling and its left child, and rotate right</span></span><br><span class="line">                        sibling.color = Color::Red;</span><br><span class="line">                        left.color = Color::Black;</span><br><span class="line">                        RBTree::<span class="title function_ invoke__">rotate_right</span>(sibling);</span><br><span class="line">                        sibling = parent.right.<span class="title function_ invoke__">as_mut</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> node.<span class="title function_ invoke__">is_right_child</span>() &amp;&amp; left.color == Color::Black &#123;</span><br><span class="line">                        <span class="comment">// Case 3: The sibling of the current node is black and the left child is black</span></span><br><span class="line">                        <span class="comment">// Change the colors of the sibling and its right child, and rotate left</span></span><br><span class="line">                        sibling.color = Color::Red;</span><br><span class="line">                        right.color = Color::Black;</span><br><span class="line">                        RBTree::<span class="title function_ invoke__">rotate_left</span>(sibling);</span><br><span class="line">                        sibling = parent.left.<span class="title function_ invoke__">as_mut</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Case 4: The sibling of the current node is black and has a red child</span></span><br><span class="line">                    <span class="comment">// Change the colors of the parent, sibling, and the child of the sibling</span></span><br><span class="line">                    sibling.color = parent.color;</span><br><span class="line">                    parent.color = Color::Black;</span><br><span class="line">                    <span class="keyword">if</span> node.<span class="title function_ invoke__">is_left_child</span>() &#123;</span><br><span class="line">                        right.color = Color::Black;</span><br><span class="line">                        RBTree::<span class="title function_ invoke__">rotate_left</span>(parent);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        left.color = Color::Black;</span><br><span class="line">                        RBTree::<span class="title function_ invoke__">rotate_right</span>(parent);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Case 2: The sibling of the current node is black and has no children</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(left) = sibling.left.<span class="title function_ invoke__">as_ref</span>() &#123;</span><br><span class="line">                    <span class="keyword">if</span> node.<span class="title function_ invoke__">is_left_child</span>() &#123;</span><br><span class="line">                        <span class="comment">// Change the color of the sibling&#x27;s left child and rotate right</span></span><br><span class="line">                        left.color = Color::Black;</span><br><span class="line">                        sibling.color = parent.color;</span><br><span class="line">                        RBTree::<span class="title function_ invoke__">rotate_right</span>(parent);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// Change the color of the sibling and its left child, and rotate right</span></span><br><span class="line">                        left.color = Color::Red;</span><br><span class="line">                        RBTree::<span class="title function_ invoke__">rotate_right</span>(sibling);</span><br><span class="line">                        sibling = parent.right.<span class="title function_ invoke__">as_mut</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> node.<span class="title function_ invoke__">is_left_child</span>() &#123;</span><br><span class="line">                        <span class="comment">// Change the color of the sibling and its left child, and rotate right</span></span><br><span class="line">                        sibling.color = Color::Red;</span><br><span class="line">                        RBTree::<span class="title function_ invoke__">rotate_right</span>(sibling);</span><br><span class="line">                        sibling = parent.right.<span class="title function_ invoke__">as_mut</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// Change the colors of the parent and sibling, and rotate left</span></span><br><span class="line">                        sibling.color = parent.color;</span><br><span class="line">                        parent.color = Color::Black;</span><br><span class="line">                        RBTree::<span class="title function_ invoke__">rotate_left</span>(parent);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the color of the current node to black</span></span><br><span class="line">    node.color = Color::Black;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// This function deletes a node from the Red-Black Tree according to the given key</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">delete</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, key: &amp;K) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">current</span> = <span class="keyword">self</span>.root.<span class="title function_ invoke__">as_mut</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Some</span>(node) = current &#123;</span><br><span class="line">        <span class="keyword">if</span> key &lt; &amp;node.key &#123;</span><br><span class="line">            current = node.left.<span class="title function_ invoke__">as_mut</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> key &gt; &amp;node.key &#123;</span><br><span class="line">            current = node.right.<span class="title function_ invoke__">as_mut</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> node.left.<span class="title function_ invoke__">is_some</span>() &amp;&amp; node.right.<span class="title function_ invoke__">is_some</span>() &#123;</span><br><span class="line">                <span class="comment">// If the node has two children, replace it with its successor and delete the successor</span></span><br><span class="line">                <span class="keyword">let</span> <span class="variable">successor</span> = node.right.<span class="title function_ invoke__">as_mut</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">min_node</span>();</span><br><span class="line">                node.key = successor.key;</span><br><span class="line">                node.value = std::mem::<span class="title function_ invoke__">replace</span>(&amp;<span class="keyword">mut</span> successor.value, <span class="built_in">Default</span>::<span class="title function_ invoke__">default</span>());</span><br><span class="line">                current = <span class="title function_ invoke__">Some</span>(&amp;<span class="keyword">mut</span> *successor);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// If the node has one child or no children, remove it and fix any Red-Black Tree violations</span></span><br><span class="line">                <span class="keyword">let</span> <span class="variable">child</span> = <span class="keyword">if</span> node.left.<span class="title function_ invoke__">is_some</span>() &#123;</span><br><span class="line">                    node.left.<span class="title function_ invoke__">take</span>()</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    node.right.<span class="title function_ invoke__">take</span>()</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> node.color == Color::Black &#123;</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(<span class="keyword">ref</span> c) = child &#123;</span><br><span class="line">                        RBTree::<span class="title function_ invoke__">fix_after_deletion</span>(c.<span class="title function_ invoke__">as_mut</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.root));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        RBTree::<span class="title function_ invoke__">fix_after_deletion</span>(node, <span class="title function_ invoke__">Some</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.root));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="title function_ invoke__">Some</span>(node.value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="literal">None</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="搜索函数"><a href="#搜索函数" class="headerlink" title="搜索函数"></a>搜索函数</h3><p>搜索函数与之前描述的搜索函数类似。我们从根节点开始，将给定键与当前节点的键进行比较。如果键相等，我们返回当前节点的值。如果给定键小于当前节点的键，我们移动到左子节点。如果给定键大于当前节点的键，则移动到右子节点。我们重复这个过程，直到我们找到具有给定键的节点或到达叶子节点。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;K: <span class="built_in">Ord</span>, V&gt; RBTree&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">search</span>(&amp;<span class="keyword">self</span>, key: &amp;K) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;V&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">current</span> = <span class="keyword">self</span>.root.<span class="title function_ invoke__">as_ref</span>(); <span class="comment">// Start search from the root of the tree.</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Some</span>(node) = current &#123; <span class="comment">// Traverse the tree until the key is found or a leaf node is reached.</span></span><br><span class="line">            <span class="keyword">if</span> key == &amp;node.key &#123; <span class="comment">// If the key is found, return the corresponding value.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="title function_ invoke__">Some</span>(&amp;node.value);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> key &lt; &amp;node.key &#123; <span class="comment">// If the key is less than the current node&#x27;s key, search the left subtree.</span></span><br><span class="line">                current = node.left.<span class="title function_ invoke__">as_ref</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// If the key is greater than the current node&#x27;s key, search the right subtree.</span></span><br><span class="line">                current = node.right.<span class="title function_ invoke__">as_ref</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="literal">None</span> <span class="comment">// If the key is not found, return None.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>红黑树是一种自平衡的二叉搜索树，用于按排序顺序存储和检索元素，所有主要操作的时间复杂度为O(log n)。它们旨在具有内存效率和平衡性，使其比其他平衡树如AVL树更有效率。Rust是一种现代编程语言，旨在提高性能和安全性，因此它是实现数据结构如红黑树的绝佳选择。</p>

            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>


    
<nav id="article-nav">
    
        <a href="/2023/03/24/A-Multifaceted-Translation-Tool-Integrating-GPT-3-5-Turbo-and-Wox-for-Seamless-Language-Processing/" id="article-nav-newer" class="article-nav-link-wrap">
            <strong class="article-nav-caption">Newer</strong>
            <div class="article-nav-title">
                
                    A Multifaceted Translation Tool: Integrating GPT-3.5 Turbo and Wox for Seamless Language Processing
                
            </div>
        </a>
    
    
        <a href="/2023/02/22/Red-Black-Tree/" id="article-nav-older" class="article-nav-link-wrap">
            <strong class="article-nav-caption">Older</strong>
            <div class="article-nav-title">Red Black Tree</div>
        </a>
    
</nav>





    
    




<!-- baidu url auto push script -->
<script type="text/javascript">
    !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=window.location.href,o=document.referrer;if(!e.test(r)){var n="//api.share.baidu.com/s.gif";o?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var t=new Image;t.src=n}}(window);
</script>     
</section>
        </div>
        <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            LightString &copy; 2023 
            <a rel="external nofollow noopener noreferrer" target="_blank" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/80x15.png"></a>
            <br> Powered by <a href="http://hexo.io/" target="_blank" rel="external nofollow noopener noreferrer">Hexo</a>. Theme - <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/zthxxx/hexo-theme-Wikitten">wikitten</a>
            
                <br>
                <span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i> <span id="busuanzi_value_site_pv"></span></span>
                &nbsp;|&nbsp;
                <span id="busuanzi_container_site_pv"><i class="fa fa-user"></i> <span id="busuanzi_value_site_uv"></span></span>
            
        </div>
    </div>
</footer>

        

    
        
<script src="/libs/lightgallery/js/lightgallery.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-pager.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-zoom.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-hash.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-share.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-video.min.js"></script>

    
    
        
<script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>

    
    
        <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true,
            TeX: {
                equationNumbers: {
                  autoNumber: 'AMS'
                }
            }
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    



<!-- Custom Scripts -->

<script src="/js/main.js"></script>


    </div>
</body>
</html>