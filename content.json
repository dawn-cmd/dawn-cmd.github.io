{"pages":[{"title":"About","date":"2023-03-21T15:47:03.499Z","path":"about/index.html","text":"Nice to meet you Im LightString. A CS major student in UW-madison. Welcome to my blog! My birthday is June 1st. Happy children’s day! ACG lover, Dark Soul player, Galgame lover, and so on. Field I interested in Machine Learning &amp; Deep Learning Algorithms &amp; Data Structures Quantitive Trading ………… Contact Email Address: &#x6c;&#x73;&#x2e;&#x68;&#x79;&#x6a;&#105;&#110;&#103;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d; School Email Address: &#x68;&#106;&#105;&#x6e;&#x67;&#55;&#64;&#119;&#105;&#x73;&#x63;&#46;&#x65;&#100;&#x75; Phone Number: (+1)9294269451 | (+86)13376173601 QQ id: 2595635885 Github: dawn-cmd StackOverflow: LightString"},{"title":"Tags","date":"2023-03-21T07:16:24.619Z","path":"tags/index.html","text":""},{"title":"Categories","date":"2023-03-21T15:36:57.490Z","path":"categories/index.html","text":""}],"posts":[{"title":"Red-Black-Tree(zh-CN)","date":"2023-03-21T16:40:46.000Z","path":"2023/03/21/Red-Black-Tree-zh-CN/","text":"English Version 摘要红黑树是一种自平衡的二叉搜索树，用于按排序顺序存储和检索元素，并具有O（log n）时间复杂度的所有主要操作。它们被设计为内存高效和平衡，使它们比其他平衡树如AVL树更高效。在本文中，我们讨论了在Rust中实现红黑树，这是一种为性能和安全性而设计的现代编程语言。我们讨论了树的结构，以及插入，删除和搜索的函数。此外，我们还讨论了修复函数，用于在每次插入和删除后恢复树的高度平衡和颜色平衡属性。最后，我们讨论了左旋和右旋函数，用于维护红黑树的平衡属性。通过使用Rust来实现红黑树，我们可以利用该语言的性能和安全性功能来创建高效且可靠的数据结构。 什么是红黑树（RBT）？红黑树是一种二叉搜索树，其中每个节点都被着色为红色或黑色。节点的颜色用于平衡树，以使从根节点到任何叶子节点的最长路径不超过从根节点到任何其他叶子节点的最短路径的两倍。此属性称为高度平衡属性。 红黑树是按照以下规则构建的 每个节点都是红色或黑色。 根节点始终为黑色。 每个叶子（NIL）节点都是黑色的。 如果一个节点为红色，则它的两个子节点必须为黑色。 从给定节点到其任何后代NIL节点的每条路径必须包含相同数量的黑色节点。 通过为每个节点分配颜色并限制连续的着色节点数量，RBT确保最长的分支永远不会超过最短分支的两倍大小，从而提供更稳定和有效的树。 以下是RBT的视觉表示： 当我们按顺序插入“1, 2, 3, 4, 5”时，以下是BST和RBT之间的比较，展示了为什么在插入排序元素时RBT远比BST有效： 很明显，当收到排序序列时，BST将变得非常低效。而RBT在此情况下可以更加平衡。 红黑树函数红黑树支持以下函数： 插入：要将新节点插入红黑树中，我们首先创建一个具有给定键和值的新节点。然后，我们遍历树以找到插入新节点的正确位置。如果树为空，我们将新节点简单地作为树的根。如果树不为空，我们将新节点的键与当前正在检查的节点的键进行比较。如果新节点的键小于当前节点的键，则移动到当前节点的左子节点。如果新节点的键大于当前节点的键，则移动到当前节点的右子节点。我们重复这个过程，直到我们找到一个可以插入新节点的空位置。 删除：要从红黑树中删除节点，我们首先搜索具有给定键的节点。如果找不到节点，我们简单地返回而不做任何事情。如果找到节点，我们用其后继节点替换它，后继节点是节点右子树中键值最小的节点。然后，我们使用类似的过程从树中删除后继节点。 搜索：在红黑树中搜索节点类似于在二叉搜索树中搜索。我们从根节点开始，将给定键与当前节点的键进行比较。如果键相等，我们返回当前节点的值。如果给定键小于当前节点的键，我们移动到左子节点。如果给定键大于当前节点的键，则移动到右子节点。我们重复这个过程，直到我们找到具有给定键的节点或到达叶子节点。 Rust中的红黑树代码要在Rust中实现红黑树，我们首先定义一个Node结构来表示树中的每个节点。Node结构包含节点的键，值，颜色和左右子节点字段。 1234567891011enum Color &#123; // Defines an enum called &#x27;Color&#x27; Red, // Enum variant representing the color red Black, // Enum variant representing the color black&#125;struct Node&lt;K, V&gt; &#123; // Defines a struct called &#x27;Node&#x27; with generic parameters &#x27;K&#x27; and &#x27;V&#x27; key: K, // Field representing the key of the node value: V, // Field representing the value of the node color: Color, // Field representing the color of the node, which is of type &#x27;Color&#x27; enum left: Option&lt;Box&lt;Node&lt;K, V&gt;&gt;&gt;, // Field representing the left child node of the current node (if exists); it is an Option type and wrapped inside a box right: Option&lt;Box&lt;Node&lt;K, V&gt;&gt;&gt;, // Field representing the right child node of the current node (if exists); it is an Option type and wrapped inside a box&#125; 我们还定义了一个RBTree结构来表示整个红黑树。RBTree结构包含一个根节点和用于插入，删除和搜索树中元素的方法。 123pub struct RBTree&lt;K: Ord, V&gt; &#123; // Defines a struct called &#x27;RBTree&#x27; with generic parameters &#x27;K&#x27; and &#x27;V&#x27;; &#x27;K&#x27; must implement &#x27;Ord&#x27; trait root: Option&lt;Box&lt;Node&lt;K, V&gt;&gt;&gt;, // Field representing the root node of the red-black tree; it is an Option type and wrapped inside a box&#125; 左旋和右旋这些函数执行给定节点及其子节点的左旋或右旋操作。rotate_left函数接收一个可变引用到一个节点，并将其右子节点向左旋转，而rotate_right函数接收一个可变引用到一个节点，并将其左子节点向右旋转。 在每次旋转期间，适当的指针被更新以反映树的新结构。每个节点的大小也被更新以反映旋转过程中发生的任何更改。 这些旋转函数由fix_after_insertion和fix_after_deletion方法用于维护红黑树的平衡属性。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152impl&lt;K: Ord, V&gt; RBTree&lt;K, V&gt; &#123; // Defines a private method called &#x27;rotate_left&#x27; that takes a mutable reference to a &#x27;Node&#x27; struct fn rotate_left(mut node: &amp;mut Node&lt;K, V&gt;) &#123; // Takes ownership of the right child node of the given node let mut right = node.right.take().unwrap(); // Moves the left child of the right child node to the right child of the given node node.right = right.left.take(); // Sets the parent of the right child node as the given node and returns the right child node right.left = Some(std::mem::replace(&amp;mut node, right)); // Sets the parent of the left child node of the given node to the given node if let Some(ref mut left) = node.left &#123; left.parent = Some(node); &#125; // Sets the parent of the right child node of the given node to the given node if let Some(ref mut right) = node.right &#123; right.parent = Some(node); &#125; // Updates the size of the given node node.update_size(); &#125; // Defines a private method called &#x27;rotate_right&#x27; that takes a mutable reference to a &#x27;Node&#x27; struct fn rotate_right(mut node: &amp;mut Node&lt;K, V&gt;) &#123; // Takes ownership of the left child node of the given node let mut left = node.left.take().unwrap(); // Moves the right child of the left child node to the left child of the given node node.left = left.right.take(); // Sets the parent of the left child node as the given node and returns the left child node left.right = Some(std::mem::replace(&amp;mut node, left)); // Sets the parent of the left child node of the given node to the given node if let Some(ref mut left) = node.left &#123; left.parent = Some(node); &#125; // Sets the parent of the right child node of the given node to the given node if let Some(ref mut right) = node.right &#123; right.parent = Some(node); &#125; // Updates the size of the given node node.update_size(); &#125;&#125; 插入函数插入函数遵循之前描述的插入函数相同的逻辑。我们创建一个具有给定键和值的新节点，并遍历树以找到插入新节点的正确位置。如果树为空，我们将新节点简单地作为树的根。如果树不为空，我们将新节点的键与当前正在检查的节点的键进行比较。如果新节点的键小于当前节点的键，则移动到当前节点的左子节点。如果新节点的键大于当前节点的键，则移动到当前节点的右子节点。我们重复这个过程，直到我们找到一个可以插入新节点的空位置。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106impl&lt;K: Ord, V&gt; RBTree&lt;K, V&gt; &#123; // Defines a private method called &#x27;fix_after_insertion&#x27; that takes a mutable reference to a &#x27;Node&#x27; struct and an optional mutable reference to the root node fn fix_after_insertion( mut node: &amp;mut Node&lt;K, V&gt;, root: Option&lt;&amp;mut Box&lt;Node&lt;K, V&gt;&gt;&gt;, ) &#123; // Sets the color of the inserted node as &#x27;Red&#x27; node.color = Color::Red; // Checks if the node is not the root node and its parent&#x27;s color is &#x27;Red&#x27; while node != root.unwrap() &amp;&amp; node.parent().unwrap().color == Color::Red &#123; let parent = node.parent().unwrap(); let grandparent = node.grandparent().unwrap(); // Checks if the parent is the left child of its grandparent if parent == grandparent.left.as_ref().unwrap() &#123; let uncle = grandparent.right.as_ref(); // Checks if the uncle node exists and its color is &#x27;Red&#x27; if uncle.is_some() &amp;&amp; uncle.unwrap().color == Color::Red &#123; // Recolors the parent, uncle, and grandparent nodes, and sets the current node to its grandparent parent.color = Color::Black; uncle.unwrap().color = Color::Black; grandparent.color = Color::Red; node = grandparent; &#125; else &#123; // Checks if the current node is the right child of its parent; if so, rotates it to the left around the parent node if node == parent.right.as_ref().unwrap() &#123; node = parent; RBTree::rotate_left(parent); &#125; // Recolors the parent and grandparent nodes, and rotates the grandparent node to the right parent.color = Color::Black; grandparent.color = Color::Red; RBTree::rotate_right(grandparent); &#125; &#125; else &#123; let uncle = grandparent.left.as_ref(); // Checks if the uncle node exists and its color is &#x27;Red&#x27; if uncle.is_some() &amp;&amp; uncle.unwrap().color == Color::Red &#123; // Recolors the parent, uncle, and grandparent nodes, and sets the current node to its grandparent parent.color = Color::Black; uncle.unwrap().color = Color::Black; grandparent.color = Color::Red; node = grandparent; &#125; else &#123; // Checks if the current node is the left child of its parent; if so, rotates it to the right around the parent node if node == parent.left.as_ref().unwrap() &#123; node = parent; RBTree::rotate_right(parent); &#125; // Recolors the parent and grandparent nodes, and rotates the grandparent node to the left parent.color = Color::Black; grandparent.color = Color::Red; RBTree::rotate_left(grandparent); &#125; &#125; &#125; root.unwrap().color = Color::Black; &#125; // Defines a public method called &#x27;insert&#x27; that takes a key and a value and adds it to the red-black tree pub fn insert(&amp;mut self, key: K, value: V) &#123; // Creates a new node with the given key, value, and color &#x27;Red&#x27; let mut new_node = Box::new(Node &#123; key, value, color: Color::Red, left: None, right: None, &#125;); // Checks if the root node exists if let Some(ref mut root) = self.root &#123; let mut current = root.as_mut(); // Traverses through the tree until it finds a suitable place to insert the new node loop &#123; if new_node.key &lt; current.key &#123; if let Some(ref mut left) = current.left &#123; current = left.as_mut(); &#125; else &#123; current.left = Some(new_node); break; &#125; &#125; else if new_node.key &gt; current.key &#123; if let Some(ref mut right) = current.right &#123; current = right.as_mut(); &#125; else &#123; current.right = Some(new_node); break; &#125; &#125; else &#123; // If the key already exists in the tree, updates its corresponding value and exits the loop current.value = new_node.value; return; &#125; &#125; // Fixes the tree after insertion of the new node RBTree::fix_after_insertion(current, Some(&amp;mut self.root)); &#125; else &#123; // If the root node does not exist, sets the color of the new node as &#x27;Black&#x27; and makes it the root node new_node.color = Color::Black; self.root = Some(new_node); &#125; &#125;&#125; 删除函数删除函数也遵循之前描述的删除函数相同的逻辑。我们搜索具有给定键的节点，并用其后继节点替换它，后继节点是节点右子树中键值最小的节点。然后，我们使用类似的过程从树中删除后继节点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140// This function fixes the Red-Black Tree violations that may arise after a node deletionfn fix_after_deletion( mut node: &amp;mut Node&lt;K, V&gt;, root: Option&lt;&amp;mut Box&lt;Node&lt;K, V&gt;&gt;&gt;,) &#123; while node != root.unwrap() &amp;&amp; node.color == Color::Black &#123; // Get the parent and sibling of the current node let parent = node.parent_mut().unwrap(); let sibling = node.sibling().unwrap(); if sibling.color == Color::Red &#123; // Case 1: The sibling of the current node is red // Change the colors of the parent, sibling, and the child of the sibling sibling.color = Color::Black; parent.color = Color::Red; if node.is_left_child() &#123; // Rotate left if the current node is the left child RBTree::rotate_left(parent); sibling.color = parent.right.as_ref().unwrap().color; parent.right.as_mut().unwrap().color = Color::Black; node = parent.left.as_mut().unwrap(); &#125; else &#123; // Rotate right if the current node is the right child RBTree::rotate_right(parent); sibling.color = parent.left.as_ref().unwrap().color; parent.left.as_mut().unwrap().color = Color::Black; node = parent.right.as_mut().unwrap(); &#125; &#125; else &#123; if let (Some(left), Some(right)) = (sibling.left.as_ref(), sibling.right.as_ref()) &#123; if left.color == Color::Black &amp;&amp; right.color == Color::Black &#123; // Case 2: The sibling of the current node is black and both its children are black // Change the colors of the sibling and move up to the parent sibling.color = Color::Red; node = parent; &#125; else &#123; if node.is_left_child() &amp;&amp; right.color == Color::Black &#123; // Case 3: The sibling of the current node is black and the right child is black // Change the colors of the sibling and its left child, and rotate right sibling.color = Color::Red; left.color = Color::Black; RBTree::rotate_right(sibling); sibling = parent.right.as_mut().unwrap(); &#125; else if node.is_right_child() &amp;&amp; left.color == Color::Black &#123; // Case 3: The sibling of the current node is black and the left child is black // Change the colors of the sibling and its right child, and rotate left sibling.color = Color::Red; right.color = Color::Black; RBTree::rotate_left(sibling); sibling = parent.left.as_mut().unwrap(); &#125; // Case 4: The sibling of the current node is black and has a red child // Change the colors of the parent, sibling, and the child of the sibling sibling.color = parent.color; parent.color = Color::Black; if node.is_left_child() &#123; right.color = Color::Black; RBTree::rotate_left(parent); &#125; else &#123; left.color = Color::Black; RBTree::rotate_right(parent); &#125; break; &#125; &#125; else &#123; // Case 2: The sibling of the current node is black and has no children if let Some(left) = sibling.left.as_ref() &#123; if node.is_left_child() &#123; // Change the color of the sibling&#x27;s left child and rotate right left.color = Color::Black; sibling.color = parent.color; RBTree::rotate_right(parent); &#125; else &#123; // Change the color of the sibling and its left child, and rotate right left.color = Color::Red; RBTree::rotate_right(sibling); sibling = parent.right.as_mut().unwrap(); &#125; &#125; else &#123; if node.is_left_child() &#123; // Change the color of the sibling and its left child, and rotate right sibling.color = Color::Red; RBTree::rotate_right(sibling); sibling = parent.right.as_mut().unwrap(); &#125; else &#123; // Change the colors of the parent and sibling, and rotate left sibling.color = parent.color; parent.color = Color::Black; RBTree::rotate_left(parent); break; &#125; &#125; &#125; &#125; &#125; // Set the color of the current node to black node.color = Color::Black;&#125;// This function deletes a node from the Red-Black Tree according to the given keypub fn delete(&amp;mut self, key: &amp;K) -&gt; Option&lt;V&gt; &#123; let mut current = self.root.as_mut(); while let Some(node) = current &#123; if key &lt; &amp;node.key &#123; current = node.left.as_mut(); &#125; else if key &gt; &amp;node.key &#123; current = node.right.as_mut(); &#125; else &#123; if node.left.is_some() &amp;&amp; node.right.is_some() &#123; // If the node has two children, replace it with its successor and delete the successor let successor = node.right.as_mut().unwrap().min_node(); node.key = successor.key; node.value = std::mem::replace(&amp;mut successor.value, Default::default()); current = Some(&amp;mut *successor); &#125; else &#123; // If the node has one child or no children, remove it and fix any Red-Black Tree violations let child = if node.left.is_some() &#123; node.left.take() &#125; else &#123; node.right.take() &#125;; if node.color == Color::Black &#123; if let Some(ref c) = child &#123; RBTree::fix_after_deletion(c.as_mut(), Some(&amp;mut self.root)); &#125; else &#123; RBTree::fix_after_deletion(node, Some(&amp;mut self.root)); &#125; &#125; return Some(node.value); &#125; &#125; &#125; None&#125; 搜索函数搜索函数与之前描述的搜索函数类似。我们从根节点开始，将给定键与当前节点的键进行比较。如果键相等，我们返回当前节点的值。如果给定键小于当前节点的键，我们移动到左子节点。如果给定键大于当前节点的键，则移动到右子节点。我们重复这个过程，直到我们找到具有给定键的节点或到达叶子节点。 1234567891011121314151617impl&lt;K: Ord, V&gt; RBTree&lt;K, V&gt; &#123; pub fn search(&amp;self, key: &amp;K) -&gt; Option&lt;&amp;V&gt; &#123; let mut current = self.root.as_ref(); // Start search from the root of the tree. while let Some(node) = current &#123; // Traverse the tree until the key is found or a leaf node is reached. if key == &amp;node.key &#123; // If the key is found, return the corresponding value. return Some(&amp;node.value); &#125; else if key &lt; &amp;node.key &#123; // If the key is less than the current node&#x27;s key, search the left subtree. current = node.left.as_ref(); &#125; else &#123; // If the key is greater than the current node&#x27;s key, search the right subtree. current = node.right.as_ref(); &#125; &#125; None // If the key is not found, return None. &#125;&#125; 结论红黑树是一种自平衡的二叉搜索树，用于按排序顺序存储和检索元素，所有主要操作的时间复杂度为O(log n)。它们旨在具有内存效率和平衡性，使其比其他平衡树如AVL树更有效率。Rust是一种现代编程语言，旨在提高性能和安全性，因此它是实现数据结构如红黑树的绝佳选择。","tags":[{"name":"data structure","slug":"data-structure","permalink":"http://example.com/tags/data-structure/"}],"categories":[{"name":"data structure & algorithm","slug":"data-structure-algorithm","permalink":"http://example.com/categories/data-structure-algorithm/"}]},{"title":"Red Black Tree","date":"2023-02-23T03:28:39.000Z","path":"2023/02/22/Red-Black-Tree/","text":"中文版链接 AbstractIn computer science, Red-Black Trees are a type of self-balancing binary search tree that are used to store and retrieve elements in sorted order with O(log n) time complexity for all major operations. They are designed to be memory-efficient and balanced, making them more efficient than other balanced trees like AVL trees. In this article, we have discussed the implementation of Red-Black Trees in Rust, a modern programming language designed for performance and safety. We have covered the structure of the tree, as well as the functions for insertion, deletion, and searching. Additionally, we have covered the fix functions that are used to restore the height balance and color balance properties of the tree after each insertion and deletion. Finally, we have discussed the left and right rotation functions that are used to maintain the balance properties of the Red-Black Tree. By using Rust to implement Red-Black Trees, we can take advantage of the language’s performance and safety features to create an efficient and reliable data structure. What is Red Black Tree (RBT)?Red-Black Trees are binary search trees where each node is colored either red or black. The color of the node is used to balance the tree so that the longest path from the root to any leaf node is no more than twice as long as the shortest path from the root to any other leaf node. This property is known as the height balance property. Red-Black Trees are constructed with the following rules Each node is either red or black. The root node is always black. Every leaf (NIL) node is black. If a node is red, then both its children must be black. Every path from a given node to any of its descendant NIL nodes must contain the same number of black nodes. By assigning each node with a color and by limiting the number of consecutive colored nodes, RBT ensures that the longest branches will never exceed twice the size of the shortest branches, thus providing a more stable and effective tree. For reference, here’s a visual representation of an RBT: Here’s a comparison between BST and RBT when we insert “1, 2, 3, 4, 5” in order, demonstrating why RBT is far more efficient than BST when sorted elements are inserted: Obviously, BST will become extremely low effective when receiving a sorted sequence. And RBT can become more balanced under this situation. Red-Black Tree FunctionsA Red-Black Tree supports the following functions: Insertion: To insert a new node into the Red-Black Tree, we first create a new node with the given key and value. We then traverse the tree to find the correct location to insert the new node. If the tree is empty, we simply make the new node the root of the tree. If the tree is not empty, we compare the new node’s key to the key of the current node we are examining. If the new node’s key is less than the current node’s key, we move to the left child of the current node. If the new node’s key is greater than the current node’s key, we move to the right child of the current node. We repeat this process until we find an empty location in the tree where we can insert the new node. Deletion: To delete a node from the Red-Black Tree, we first search for the node with the given key. If the node is not found, we simply return without doing anything. If the node is found, we replace it with its successor, which is the node with the smallest key in the node’s right subtree. We then delete the successor node from the tree using a similar process. Searching: Searching for a node in the Red-Black Tree is similar to searching in a binary search tree. We start at the root node and compare the given key with the key of the current node. If the keys are equal, we return the value of the current node. If the given key is less than the key of the current node, we move to the left child. If the given key is greater than the key of the current node, we move to the right child. We repeat this process until we find the node with the given key or reach a leaf node. Rust Code for Red-Black TreesTo implement Red-Black Trees in Rust, we first define a Node struct to represent each node in the tree. The Node struct contains fields for the node’s key, value, color, and left and right children. 1234567891011enum Color &#123; // Defines an enum called &#x27;Color&#x27; Red, // Enum variant representing the color red Black, // Enum variant representing the color black&#125;struct Node&lt;K, V&gt; &#123; // Defines a struct called &#x27;Node&#x27; with generic parameters &#x27;K&#x27; and &#x27;V&#x27; key: K, // Field representing the key of the node value: V, // Field representing the value of the node color: Color, // Field representing the color of the node, which is of type &#x27;Color&#x27; enum left: Option&lt;Box&lt;Node&lt;K, V&gt;&gt;&gt;, // Field representing the left child node of the current node (if exists); it is an Option type and wrapped inside a box right: Option&lt;Box&lt;Node&lt;K, V&gt;&gt;&gt;, // Field representing the right child node of the current node (if exists); it is an Option type and wrapped inside a box&#125; We also define an RBTree struct to represent the Red-Black Tree as a whole. The RBTree struct contains a root node and methods to insert, delete, and search for elements in the tree. 123pub struct RBTree&lt;K: Ord, V&gt; &#123; // Defines a struct called &#x27;RBTree&#x27; with generic parameters &#x27;K&#x27; and &#x27;V&#x27;; &#x27;K&#x27; must implement &#x27;Ord&#x27; trait root: Option&lt;Box&lt;Node&lt;K, V&gt;&gt;&gt;, // Field representing the root node of the red-black tree; it is an Option type and wrapped inside a box&#125; Left and Right RotateThese functions perform a left or right rotation of a given node and its children. The rotate_left function takes in a mutable reference to a node and rotates its right child to the left, while the rotate_right function takes in a mutable reference to a node and rotates its left child to the right. During each rotation, the appropriate pointers are updated to reflect the new structure of the tree. The size of each node is also updated to reflect any changes that occurred during the rotation. These rotation functions are used by the fix_after_insertion and fix_after_deletion methods to maintain the balance properties of the Red-Black Tree. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152impl&lt;K: Ord, V&gt; RBTree&lt;K, V&gt; &#123; // Defines a private method called &#x27;rotate_left&#x27; that takes a mutable reference to a &#x27;Node&#x27; struct fn rotate_left(mut node: &amp;mut Node&lt;K, V&gt;) &#123; // Takes ownership of the right child node of the given node let mut right = node.right.take().unwrap(); // Moves the left child of the right child node to the right child of the given node node.right = right.left.take(); // Sets the parent of the right child node as the given node and returns the right child node right.left = Some(std::mem::replace(&amp;mut node, right)); // Sets the parent of the left child node of the given node to the given node if let Some(ref mut left) = node.left &#123; left.parent = Some(node); &#125; // Sets the parent of the right child node of the given node to the given node if let Some(ref mut right) = node.right &#123; right.parent = Some(node); &#125; // Updates the size of the given node node.update_size(); &#125; // Defines a private method called &#x27;rotate_right&#x27; that takes a mutable reference to a &#x27;Node&#x27; struct fn rotate_right(mut node: &amp;mut Node&lt;K, V&gt;) &#123; // Takes ownership of the left child node of the given node let mut left = node.left.take().unwrap(); // Moves the right child of the left child node to the left child of the given node node.left = left.right.take(); // Sets the parent of the left child node as the given node and returns the left child node left.right = Some(std::mem::replace(&amp;mut node, left)); // Sets the parent of the left child node of the given node to the given node if let Some(ref mut left) = node.left &#123; left.parent = Some(node); &#125; // Sets the parent of the right child node of the given node to the given node if let Some(ref mut right) = node.right &#123; right.parent = Some(node); &#125; // Updates the size of the given node node.update_size(); &#125;&#125; Insertion Function in RustThe insert function in Rust follows the same logic as the insertion function described earlier. We create a new node with the given key and value and traverse the tree to find the correct location to insert the new node. If the tree is empty, we simply make the new node the root of the tree. If the tree is not empty, we compare the new node’s key to the key of the current node we are examining. If the new node’s key is less than the current node’s key, we move to the left child of the current node. If the new node’s key is greater than the current node’s key, we move to the right child of the current node. We repeat this process until we find an empty location in the tree where we can insert the new node. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106impl&lt;K: Ord, V&gt; RBTree&lt;K, V&gt; &#123; // Defines a private method called &#x27;fix_after_insertion&#x27; that takes a mutable reference to a &#x27;Node&#x27; struct and an optional mutable reference to the root node fn fix_after_insertion( mut node: &amp;mut Node&lt;K, V&gt;, root: Option&lt;&amp;mut Box&lt;Node&lt;K, V&gt;&gt;&gt;, ) &#123; // Sets the color of the inserted node as &#x27;Red&#x27; node.color = Color::Red; // Checks if the node is not the root node and its parent&#x27;s color is &#x27;Red&#x27; while node != root.unwrap() &amp;&amp; node.parent().unwrap().color == Color::Red &#123; let parent = node.parent().unwrap(); let grandparent = node.grandparent().unwrap(); // Checks if the parent is the left child of its grandparent if parent == grandparent.left.as_ref().unwrap() &#123; let uncle = grandparent.right.as_ref(); // Checks if the uncle node exists and its color is &#x27;Red&#x27; if uncle.is_some() &amp;&amp; uncle.unwrap().color == Color::Red &#123; // Recolors the parent, uncle, and grandparent nodes, and sets the current node to its grandparent parent.color = Color::Black; uncle.unwrap().color = Color::Black; grandparent.color = Color::Red; node = grandparent; &#125; else &#123; // Checks if the current node is the right child of its parent; if so, rotates it to the left around the parent node if node == parent.right.as_ref().unwrap() &#123; node = parent; RBTree::rotate_left(parent); &#125; // Recolors the parent and grandparent nodes, and rotates the grandparent node to the right parent.color = Color::Black; grandparent.color = Color::Red; RBTree::rotate_right(grandparent); &#125; &#125; else &#123; let uncle = grandparent.left.as_ref(); // Checks if the uncle node exists and its color is &#x27;Red&#x27; if uncle.is_some() &amp;&amp; uncle.unwrap().color == Color::Red &#123; // Recolors the parent, uncle, and grandparent nodes, and sets the current node to its grandparent parent.color = Color::Black; uncle.unwrap().color = Color::Black; grandparent.color = Color::Red; node = grandparent; &#125; else &#123; // Checks if the current node is the left child of its parent; if so, rotates it to the right around the parent node if node == parent.left.as_ref().unwrap() &#123; node = parent; RBTree::rotate_right(parent); &#125; // Recolors the parent and grandparent nodes, and rotates the grandparent node to the left parent.color = Color::Black; grandparent.color = Color::Red; RBTree::rotate_left(grandparent); &#125; &#125; &#125; root.unwrap().color = Color::Black; &#125; // Defines a public method called &#x27;insert&#x27; that takes a key and a value and adds it to the red-black tree pub fn insert(&amp;mut self, key: K, value: V) &#123; // Creates a new node with the given key, value, and color &#x27;Red&#x27; let mut new_node = Box::new(Node &#123; key, value, color: Color::Red, left: None, right: None, &#125;); // Checks if the root node exists if let Some(ref mut root) = self.root &#123; let mut current = root.as_mut(); // Traverses through the tree until it finds a suitable place to insert the new node loop &#123; if new_node.key &lt; current.key &#123; if let Some(ref mut left) = current.left &#123; current = left.as_mut(); &#125; else &#123; current.left = Some(new_node); break; &#125; &#125; else if new_node.key &gt; current.key &#123; if let Some(ref mut right) = current.right &#123; current = right.as_mut(); &#125; else &#123; current.right = Some(new_node); break; &#125; &#125; else &#123; // If the key already exists in the tree, updates its corresponding value and exits the loop current.value = new_node.value; return; &#125; &#125; // Fixes the tree after insertion of the new node RBTree::fix_after_insertion(current, Some(&amp;mut self.root)); &#125; else &#123; // If the root node does not exist, sets the color of the new node as &#x27;Black&#x27; and makes it the root node new_node.color = Color::Black; self.root = Some(new_node); &#125; &#125;&#125; Deletion Function in RustThe delete function in Rust also follows the same logic as the deletion function described earlier. We search for the node with the given key and replace it with its successor, which is the node with the smallest key in the node’s right subtree. We then delete the successor node from the tree using a similar process. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140// This function fixes the Red-Black Tree violations that may arise after a node deletionfn fix_after_deletion( mut node: &amp;mut Node&lt;K, V&gt;, root: Option&lt;&amp;mut Box&lt;Node&lt;K, V&gt;&gt;&gt;,) &#123; while node != root.unwrap() &amp;&amp; node.color == Color::Black &#123; // Get the parent and sibling of the current node let parent = node.parent_mut().unwrap(); let sibling = node.sibling().unwrap(); if sibling.color == Color::Red &#123; // Case 1: The sibling of the current node is red // Change the colors of the parent, sibling, and the child of the sibling sibling.color = Color::Black; parent.color = Color::Red; if node.is_left_child() &#123; // Rotate left if the current node is the left child RBTree::rotate_left(parent); sibling.color = parent.right.as_ref().unwrap().color; parent.right.as_mut().unwrap().color = Color::Black; node = parent.left.as_mut().unwrap(); &#125; else &#123; // Rotate right if the current node is the right child RBTree::rotate_right(parent); sibling.color = parent.left.as_ref().unwrap().color; parent.left.as_mut().unwrap().color = Color::Black; node = parent.right.as_mut().unwrap(); &#125; &#125; else &#123; if let (Some(left), Some(right)) = (sibling.left.as_ref(), sibling.right.as_ref()) &#123; if left.color == Color::Black &amp;&amp; right.color == Color::Black &#123; // Case 2: The sibling of the current node is black and both its children are black // Change the colors of the sibling and move up to the parent sibling.color = Color::Red; node = parent; &#125; else &#123; if node.is_left_child() &amp;&amp; right.color == Color::Black &#123; // Case 3: The sibling of the current node is black and the right child is black // Change the colors of the sibling and its left child, and rotate right sibling.color = Color::Red; left.color = Color::Black; RBTree::rotate_right(sibling); sibling = parent.right.as_mut().unwrap(); &#125; else if node.is_right_child() &amp;&amp; left.color == Color::Black &#123; // Case 3: The sibling of the current node is black and the left child is black // Change the colors of the sibling and its right child, and rotate left sibling.color = Color::Red; right.color = Color::Black; RBTree::rotate_left(sibling); sibling = parent.left.as_mut().unwrap(); &#125; // Case 4: The sibling of the current node is black and has a red child // Change the colors of the parent, sibling, and the child of the sibling sibling.color = parent.color; parent.color = Color::Black; if node.is_left_child() &#123; right.color = Color::Black; RBTree::rotate_left(parent); &#125; else &#123; left.color = Color::Black; RBTree::rotate_right(parent); &#125; break; &#125; &#125; else &#123; // Case 2: The sibling of the current node is black and has no children if let Some(left) = sibling.left.as_ref() &#123; if node.is_left_child() &#123; // Change the color of the sibling&#x27;s left child and rotate right left.color = Color::Black; sibling.color = parent.color; RBTree::rotate_right(parent); &#125; else &#123; // Change the color of the sibling and its left child, and rotate right left.color = Color::Red; RBTree::rotate_right(sibling); sibling = parent.right.as_mut().unwrap(); &#125; &#125; else &#123; if node.is_left_child() &#123; // Change the color of the sibling and its left child, and rotate right sibling.color = Color::Red; RBTree::rotate_right(sibling); sibling = parent.right.as_mut().unwrap(); &#125; else &#123; // Change the colors of the parent and sibling, and rotate left sibling.color = parent.color; parent.color = Color::Black; RBTree::rotate_left(parent); break; &#125; &#125; &#125; &#125; &#125; // Set the color of the current node to black node.color = Color::Black;&#125;// This function deletes a node from the Red-Black Tree according to the given keypub fn delete(&amp;mut self, key: &amp;K) -&gt; Option&lt;V&gt; &#123; let mut current = self.root.as_mut(); while let Some(node) = current &#123; if key &lt; &amp;node.key &#123; current = node.left.as_mut(); &#125; else if key &gt; &amp;node.key &#123; current = node.right.as_mut(); &#125; else &#123; if node.left.is_some() &amp;&amp; node.right.is_some() &#123; // If the node has two children, replace it with its successor and delete the successor let successor = node.right.as_mut().unwrap().min_node(); node.key = successor.key; node.value = std::mem::replace(&amp;mut successor.value, Default::default()); current = Some(&amp;mut *successor); &#125; else &#123; // If the node has one child or no children, remove it and fix any Red-Black Tree violations let child = if node.left.is_some() &#123; node.left.take() &#125; else &#123; node.right.take() &#125;; if node.color == Color::Black &#123; if let Some(ref c) = child &#123; RBTree::fix_after_deletion(c.as_mut(), Some(&amp;mut self.root)); &#125; else &#123; RBTree::fix_after_deletion(node, Some(&amp;mut self.root)); &#125; &#125; return Some(node.value); &#125; &#125; &#125; None&#125; Searching Function in RustThe search function in Rust is also similar to the search function described earlier. We start at the root node and compare the given key with the key of the current node. If the keys are equal, we return the value of the current node. If the given key is less than the key of the current node, we move to the left child. If the given key is greater than the key of the current node, we move to the right child. We repeat this process until we find the node with the given key or reach a leaf node. 1234567891011121314151617impl&lt;K: Ord, V&gt; RBTree&lt;K, V&gt; &#123; pub fn search(&amp;self, key: &amp;K) -&gt; Option&lt;&amp;V&gt; &#123; let mut current = self.root.as_ref(); // Start search from the root of the tree. while let Some(node) = current &#123; // Traverse the tree until the key is found or a leaf node is reached. if key == &amp;node.key &#123; // If the key is found, return the corresponding value. return Some(&amp;node.value); &#125; else if key &lt; &amp;node.key &#123; // If the key is less than the current node&#x27;s key, search the left subtree. current = node.left.as_ref(); &#125; else &#123; // If the key is greater than the current node&#x27;s key, search the right subtree. current = node.right.as_ref(); &#125; &#125; None // If the key is not found, return None. &#125;&#125; ConclusionRed-Black Trees are a type of self-balancing binary search tree that are used to store and retrieve elements in sorted order with O(log n) time complexity for all major operations. They are designed to be memory efficient and balanced, making them more efficient than other balanced trees like AVL trees. Rust is a modern programming language that is designed for performance and safety, making it a great choice for implementing data structures like the Red-Black Tree.","tags":[{"name":"data structure","slug":"data-structure","permalink":"http://example.com/tags/data-structure/"}],"categories":[{"name":"data structure & algorithm","slug":"data-structure-algorithm","permalink":"http://example.com/categories/data-structure-algorithm/"}]},{"title":"Self Description","date":"2023-02-13T08:26:01.000Z","path":"2023/02/13/SelfDescription/","text":"Nice to meet you Im LightString. A CS major student in UW-madison. Welcome to my blog! My birthday is June 1st. Happy children’s day! ACG lover, Dark Soul player, Galgame lover, and so on. Field I interested in Machine Learning &amp; Deep Learning Algorithms &amp; Data Structures Quantitive Trading ………… Contact Email Address: &#108;&#115;&#x2e;&#104;&#x79;&#x6a;&#x69;&#x6e;&#x67;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109; School Email Address: &#104;&#106;&#105;&#x6e;&#x67;&#55;&#64;&#x77;&#105;&#115;&#x63;&#x2e;&#101;&#x64;&#x75; Phone Number: (+1)9294269451 | (+86)13376173601 QQ id: 2595635885 Github: dawn-cmd StackOverflow: LightString","tags":[],"categories":[]}],"categories":[{"name":"data structure & algorithm","slug":"data-structure-algorithm","permalink":"http://example.com/categories/data-structure-algorithm/"}],"tags":[{"name":"data structure","slug":"data-structure","permalink":"http://example.com/tags/data-structure/"}]}