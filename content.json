{"pages":[{"title":"About","date":"2023-03-21T14:50:49.629Z","path":"about/index.html","text":"Nice to meet you Im LightString. A CS major student in UW-madison. Welcome to my blog! My birthday is June 1st. Happy children’s day! ACG lover, Dark Soul player, Galgame lover, and so on. Field I interested in Machine Learning &amp; Deep Learning Algorithms &amp; Data Structures Quantitive Trading ………… Contact Email Address: &#108;&#x73;&#46;&#x68;&#x79;&#x6a;&#105;&#x6e;&#103;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#111;&#109; School Email Address: &#x68;&#x6a;&#105;&#x6e;&#x67;&#55;&#x40;&#x77;&#105;&#x73;&#99;&#x2e;&#101;&#100;&#x75; Phone Number: (+1)9294269451 | (+86)13376173601 QQ id: 2595635885"},{"title":"Tags","date":"2023-03-21T07:16:24.619Z","path":"tags/index.html","text":""},{"title":"Categories","date":"2023-03-21T14:53:52.770Z","path":"categories/index.html","text":""}],"posts":[{"title":"Red Black Tree","date":"2023-02-23T03:28:39.000Z","path":"2023/02/22/Red-Black-Tree/","text":"What is Red Black Tree (RBT)?Today let’s talk about Red Black Tree (RBT). Red Black is a kind of balanced binary search tree. Unlike regular binary search trees (BST), the speed of an RBT remains relatively consistent no matter the height of the tree, due to its self-balancing property. This attribute is achieved through a set of limitations placed on the depth and color of each node in the tree. Properties of RBT All properties of normal binary search trees All nodes on trees have two colors: red and black A red node cannot has red child or parent nodes The root node must be black The number of black nodes on each path from root to leaf node must be sameBy assigning each node with a color and by limiting the number of consecutive colored nodes, RBT ensures that the longest branches will never exceed twice the size of the shortest branches, thus providing a more stable and effective tree. For reference, here’s a visual representation of an RBT:Here’s a comparison between BST and RBT when we insert “1, 2, 3, 4, 5” in order, demonstrating why RBT is far more efficient than BST when sorted elements are inserted:Obviously, BST will become extremely low effective when receiving a sorted sequence. And RBT can become more balanced under this situation. Search of RBTSearching an RBT is just like searching any other binary search tree – if the value of the current node is larger than the target value, the search should continue on its left child; otherwise, it should continue on its right child. Here’s an example implementation using C++: 1234567891011121314151617vector&lt;string&gt; search(int val) &#123; Node *cur = root; while (cur != nullptr) &#123; // If the current node is the goal, return it if (cur-&gt;val == val) &#123; return move(cur-&gt;data); &#125; // Decide whether to continue searching left or right cur = cur-&gt;val &lt; val ? cur-&gt;left : cur-&gt;right; &#125; // Returns a empty vector if not found vector&lt;string&gt; tmp; return move(tmp);&#125; Rotate Option of RBTRotate option is the key function that helps the tree balance itself without breaking its properties. There are two kinds of rotation: left rotation and right rotation. Left rotation let the left branch’s height + 1, right branch’s height - 1, right rotation reverse. Left Rotate123456789101112131415161718192021222324252627282930Node *leftRotate(Node *cur) &#123; //Store cur&#x27;s right&#x27;s left node in tmp Node *tmp = cur-&gt;right-&gt;left; //Set cur-&gt;right-&gt;left to cur cur-&gt;right-&gt;left = cur; //Set cur-&gt;parent as cur-&gt;right cur-&gt;right-&gt;parent = cur-&gt;parent; //Set cur-&gt;parent to cur-&gt;right cur-&gt;parent = cur-&gt;right; //Set cur-&gt;right to the previously stored tmp //node cur-&gt;right = tmp; //Set cur-&gt;parent-&gt;left to cur cur-&gt;parent-&gt;left = cur; //Set tmp&#x27;s parent to cur tmp-&gt;parent = cur; //Determine root node when cur is being rotated. if (root == cur) &#123; root = cur-&gt;parent; &#125; else &#123; //Check if Parent of the current node has cur as its left or right child if (cur-&gt;parent-&gt;parent-&gt;left == cur) &#123; cur-&gt;parent-&gt;parent-&gt;left = cur-&gt;parent; &#125; else &#123; cur-&gt;parent-&gt;parent-&gt;right = cur-&gt;parent; &#125; &#125; //Return the new parent node return cur-&gt;parent;&#125; Right rotate123456789101112131415161718192021222324252627282930Node *rightRotate(Node *cur) &#123; // Store the subsidiary node before changing its pointer Node *tmp = cur-&gt;left-&gt;right; // Make the connection between the right child of left child and the current node cur-&gt;left-&gt;right = cur; // Update the parent pointer of the right child of left child cur-&gt;left-&gt;parent = cur-&gt;parent; // Move the parent pointer of the current node to its left child cur-&gt;parent = cur-&gt;left; // Replace the right child of the current node with the auxiliary node cur-&gt;left = tmp; // Connect the auxiliary node with the current node cur-&gt;parent-&gt;right = cur; // Move parent pointer from auxiliary node to cur tmp-&gt;parent = cur; // Check if the current node is root or not if (root == cur) &#123; // If it&#x27;s, update the root pointer to its parent root = cur-&gt;parent; &#125; // Check if the grand parent of the current node has a left or right child else if (cur-&gt;parent-&gt;parent-&gt;left == cur) &#123; // If it has a left child, that must be the parent of the current node cur-&gt;parent-&gt;parent-&gt;left = cur-&gt;parent; &#125; else &#123; // If it has a right child, that must be the parent of the current node cur-&gt;parent-&gt;parent-&gt;right = cur-&gt;parent; &#125; return cur-&gt;parent;// Return new node after zig operation&#125; Insert option of RBTBecause of the properties of RBT, its insert option will be more complicated than normal BST. Specifically, we can break the insert option into two steps: insert and balance. Many platforms combine the two parts with together, but from my perspective, it is not convenient for understanding. InsertThe insert option is similar to BST’s insert option. Find the approrate position and make a new node on the tree with the target value and key. When it comes to RBT, we only need to care about the new node must be RED at first. 1234567891011121314151617181920212223242526272829void insert(int val, const string &amp;data) &#123; if (root == nullptr) &#123; root = new Node&#123;val&#125;; root-&gt;is_red = 0; root-&gt;data.emplace_back(data); return; &#125; Node *cur = root; Node *pre = nullptr; while (cur != nullptr) &#123; pre = cur; if (val == cur-&gt;val) &#123; cur-&gt;data.emplace_back(data); return; &#125; if (val &lt; cur-&gt;val) &#123; cur = cur-&gt;left; continue; &#125; if (val &gt; cur-&gt;val) &#123; cur = cur-&gt;right; continue; &#125; &#125; cur = new Node&#123;val&#125;; cur-&gt;data.emplace_back(data); cur-&gt;is_red = 1; cur-&gt;parent = pre;&#125; BalanceThe balance option is the key of RBT, which implement by left rotation and right rotation. Here are the strategy of balance: When the current node is the root, just turn it black.","tags":[{"name":"data structure","slug":"data-structure","permalink":"http://example.com/tags/data-structure/"}],"categories":[]},{"title":"Self Description","date":"2023-02-13T08:26:01.000Z","path":"2023/02/13/SelfDescription/","text":"Nice to meet you Im LightString. A CS major student in UW-madison. Welcome to my blog! My birthday is June 1st. Happy children’s day! ACG lover, Dark Soul player, Galgame lover, and so on. Field I interested in Machine Learning &amp; Deep Learning Algorithms &amp; Data Structures Quantitive Trading ………… Contact Email Address: &#x6c;&#x73;&#46;&#x68;&#121;&#106;&#x69;&#x6e;&#x67;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#109; School Email Address: &#x68;&#x6a;&#105;&#x6e;&#x67;&#55;&#x40;&#x77;&#x69;&#x73;&#99;&#x2e;&#x65;&#x64;&#x75; Phone Number: (+1)9294269451 | (+86)13376173601 QQ id: 2595635885","tags":[],"categories":[]}],"categories":[],"tags":[{"name":"data structure","slug":"data-structure","permalink":"http://example.com/tags/data-structure/"}]}