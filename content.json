{"pages":[{"title":"About","date":"2023-03-21T15:47:03.499Z","path":"about/index.html","text":"Nice to meet you Im LightString. A CS major student in UW-madison. Welcome to my blog! My birthday is June 1st. Happy children’s day! ACG lover, Dark Soul player, Galgame lover, and so on. Field I interested in Machine Learning &amp; Deep Learning Algorithms &amp; Data Structures Quantitive Trading ………… Contact Email Address: &#x6c;&#x73;&#x2e;&#x68;&#x79;&#x6a;&#105;&#110;&#103;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d; School Email Address: &#x68;&#106;&#105;&#x6e;&#x67;&#55;&#64;&#119;&#105;&#x73;&#x63;&#46;&#x65;&#100;&#x75; Phone Number: (+1)9294269451 | (+86)13376173601 QQ id: 2595635885 Github: dawn-cmd StackOverflow: LightString"},{"title":"Tags","date":"2023-03-21T07:16:24.619Z","path":"tags/index.html","text":""},{"title":"Categories","date":"2023-03-21T15:36:57.490Z","path":"categories/index.html","text":""}],"posts":[{"title":"Red Black Tree","date":"2023-02-23T03:28:39.000Z","path":"2023/02/22/Red-Black-Tree/","text":"What is Red Black Tree (RBT)?Red-Black Trees are binary search trees where each node is colored either red or black. The color of the node is used to balance the tree so that the longest path from the root to any leaf node is no more than twice as long as the shortest path from the root to any other leaf node. This property is known as the height balance property. Red-Black Trees are constructed with the following rules Each node is either red or black. The root node is always black. Every leaf (NIL) node is black. If a node is red, then both its children must be black. Every path from a given node to any of its descendant NIL nodes must contain the same number of black nodes. By assigning each node with a color and by limiting the number of consecutive colored nodes, RBT ensures that the longest branches will never exceed twice the size of the shortest branches, thus providing a more stable and effective tree. For reference, here’s a visual representation of an RBT: Here’s a comparison between BST and RBT when we insert “1, 2, 3, 4, 5” in order, demonstrating why RBT is far more efficient than BST when sorted elements are inserted: Obviously, BST will become extremely low effective when receiving a sorted sequence. And RBT can become more balanced under this situation. Red-Black Tree FunctionsA Red-Black Tree supports the following functions: Insertion: To insert a new node into the Red-Black Tree, we first create a new node with the given key and value. We then traverse the tree to find the correct location to insert the new node. If the tree is empty, we simply make the new node the root of the tree. If the tree is not empty, we compare the new node’s key to the key of the current node we are examining. If the new node’s key is less than the current node’s key, we move to the left child of the current node. If the new node’s key is greater than the current node’s key, we move to the right child of the current node. We repeat this process until we find an empty location in the tree where we can insert the new node. Deletion: To delete a node from the Red-Black Tree, we first search for the node with the given key. If the node is not found, we simply return without doing anything. If the node is found, we replace it with its successor, which is the node with the smallest key in the node’s right subtree. We then delete the successor node from the tree using a similar process. Searching: Searching for a node in the Red-Black Tree is similar to searching in a binary search tree. We start at the root node and compare the given key with the key of the current node. If the keys are equal, we return the value of the current node. If the given key is less than the key of the current node, we move to the left child. If the given key is greater than the key of the current node, we move to the right child. We repeat this process until we find the node with the given key or reach a leaf node. Rust Code for Red-Black TreesTo implement Red-Black Trees in Rust, we first define a Node struct to represent each node in the tree. The Node struct contains fields for the node’s key, value, color, and left and right children. 1234567891011enum Color &#123; Red, Black,&#125;struct Node&lt;K, V&gt; &#123; key: K, value: V, color: Color, left: Option&lt;Box&lt;Node&lt;K, V&gt;&gt;&gt;, right: Option&lt;Box&lt;Node&lt;K, V&gt;&gt;&gt;,&#125; We also define an RBTree struct to represent the Red-Black Tree as a whole. The RBTree struct contains a root node and methods to insert, delete, and search for elements in the tree. 123pub struct RBTree&lt;K: Ord, V&gt; &#123; root: Option&lt;Box&lt;Node&lt;K, V&gt;&gt;&gt;,&#125; Insertion Function in RustThe insert function in Rust follows the same logic as the insertion function described earlier. We create a new node with the given key and value and traverse the tree to find the correct location to insert the new node. If the tree is empty, we simply make the new node the root of the tree. If the tree is not empty, we compare the new node’s key to the key of the current node we are examining. If the new node’s key is less than the current node’s key, we move to the left child of the current node. If the new node’s key is greater than the current node’s key, we move to the right child of the current node. We repeat this process until we find an empty location in the tree where we can insert the new node. 12345678910111213141516171819202122232425262728293031323334353637383940impl&lt;K: Ord, V&gt; RBTree&lt;K, V&gt; &#123; pub fn insert(&amp;mut self, key: K, value: V) &#123; let mut new_node = Box::new(Node &#123; key, value, color: Color::Red, left: None, right: None, &#125;); if let Some(ref mut root) = self.root &#123; let mut current = root.as_mut(); loop &#123; if new_node.key &lt; current.key &#123; if let Some(ref mut left) = current.left &#123; current = left.as_mut(); &#125; else &#123; current.left = Some(new_node); break; &#125; &#125; else if new_node.key &gt; current.key &#123; if let Some(ref mut right) = current.right &#123; current = right.as_mut(); &#125; else &#123; current.right = Some(new_node); break; &#125; &#125; else &#123; current.value = new_node.value; return; &#125; &#125; RBTree::fix_after_insertion(current, Some(&amp;mut self.root)); &#125; else &#123; new_node.color = Color::Black; self.root = Some(new_node); &#125; &#125;&#125; Deletion Function in RustThe delete function in Rust also follows the same logic as the deletion function described earlier. We search for the node with the given key and replace it with its successor, which is the node with the smallest key in the node’s right subtree. We then delete the successor node from the tree using a similar process. 12345678910111213141516171819202122232425262728293031323334353637impl&lt;K: Ord, V&gt; RBTree&lt;K, V&gt; &#123; pub fn delete(&amp;mut self, key: &amp;K) -&gt; Option&lt;V&gt; &#123; let mut current = self.root.as_mut(); while let Some(node) = current &#123; if key &lt; &amp;node.key &#123; current = node.left.as_mut(); &#125; else if key &gt; &amp;node.key &#123; current = node.right.as_mut(); &#125; else &#123; if node.left.is_some() &amp;&amp; node.right.is_some() &#123; let successor = node.right.as_mut().unwrap().min_node(); node.key = successor.key; node.value = std::mem::replace(&amp;mut successor.value, Default::default()); current = Some(&amp;mut *successor); &#125; else &#123; let child = if node.left.is_some() &#123; node.left.take() &#125; else &#123; node.right.take() &#125;; if node.color == Color::Black &#123; if let Some(ref c) = child &#123; RBTree::fix_after_deletion(c.as_mut(), Some(&amp;mut self.root)); &#125; else &#123; RBTree::fix_after_deletion(node, Some(&amp;mut self.root)); &#125; &#125; return Some(node.value); &#125; &#125; &#125; None&#125; Searching Function in RustThe search function in Rust is also similar to the search function described earlier. We start at the root node and compare the given key with the key of the current node. If the keys are equal, we return the value of the current node. If the given key is less than the key of the current node, we move to the left child. If the given key is greater than the key of the current node, we move to the right child. We repeat this process until we find the node with the given key or reach a leaf node. 1234567891011121314151617impl&lt;K: Ord, V&gt; RBTree&lt;K, V&gt; &#123; pub fn search(&amp;self, key: &amp;K) -&gt; Option&lt;&amp;V&gt; &#123; let mut current = self.root.as_ref(); while let Some(node) = current &#123; if key == &amp;node.key &#123; return Some(&amp;node.value); &#125; else if key &lt; &amp;node.key &#123; current = node.left.as_ref(); &#125; else &#123; current = node.right.as_ref(); &#125; &#125; None &#125;&#125; ConclusionRed-Black Trees are a type of self-balancing binary search tree that are used to store and retrieve elements in sorted order with O(log n) time complexity for all major operations. They are designed to be memory efficient and balanced, making them more efficient than other balanced trees like AVL trees. Rust is a modern programming language that is designed for performance and safety, making it a great choice for implementing data structures like the Red-Black Tree.","tags":[{"name":"data structure","slug":"data-structure","permalink":"http://example.com/tags/data-structure/"}],"categories":[{"name":"data structure & algorithm","slug":"data-structure-algorithm","permalink":"http://example.com/categories/data-structure-algorithm/"}]},{"title":"Self Description","date":"2023-02-13T08:26:01.000Z","path":"2023/02/13/SelfDescription/","text":"Nice to meet you Im LightString. A CS major student in UW-madison. Welcome to my blog! My birthday is June 1st. Happy children’s day! ACG lover, Dark Soul player, Galgame lover, and so on. Field I interested in Machine Learning &amp; Deep Learning Algorithms &amp; Data Structures Quantitive Trading ………… Contact Email Address: &#108;&#115;&#x2e;&#104;&#x79;&#x6a;&#x69;&#x6e;&#x67;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109; School Email Address: &#104;&#106;&#105;&#x6e;&#x67;&#55;&#64;&#x77;&#105;&#115;&#x63;&#x2e;&#101;&#x64;&#x75; Phone Number: (+1)9294269451 | (+86)13376173601 QQ id: 2595635885 Github: dawn-cmd StackOverflow: LightString","tags":[],"categories":[]}],"categories":[{"name":"data structure & algorithm","slug":"data-structure-algorithm","permalink":"http://example.com/categories/data-structure-algorithm/"}],"tags":[{"name":"data structure","slug":"data-structure","permalink":"http://example.com/tags/data-structure/"}]}